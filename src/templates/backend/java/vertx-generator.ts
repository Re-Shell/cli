import { JavaBackendGenerator } from './java-base-generator';
import { promises as fs } from 'fs';
import * as path from 'path';

export class VertxGenerator extends JavaBackendGenerator {
  constructor() {
    super('Vert.x');
  }

  protected async createJavaDirectoryStructure(projectPath: string): Promise<void> {
    const packagePath = this.getPackagePath();
    
    const directories = [
      'src/main/java',
      `src/main/java/${packagePath}`,
      `src/main/java/${packagePath}/verticle`,
      `src/main/java/${packagePath}/handler`,
      `src/main/java/${packagePath}/service`,
      `src/main/java/${packagePath}/repository`,
      `src/main/java/${packagePath}/model`,
      `src/main/java/${packagePath}/dto`,
      `src/main/java/${packagePath}/config`,
      `src/main/java/${packagePath}/codec`,
      `src/main/java/${packagePath}/exception`,
      `src/main/java/${packagePath}/util`,
      'src/main/resources',
      'src/main/resources/db',
      'src/main/resources/db/migration',
      'src/main/resources/webroot',
      'src/test/java',
      `src/test/java/${packagePath}`,
      `src/test/java/${packagePath}/verticle`,
      `src/test/java/${packagePath}/handler`,
      `src/test/java/${packagePath}/service`,
      `src/test/java/${packagePath}/integration`,
      'src/test/resources',
      'target',
      'conf',
      '.mvn',
      '.mvn/wrapper'
    ];

    for (const dir of directories) {
      await fs.mkdir(path.join(projectPath, dir), { recursive: true });
    }
  }

  protected async generateFrameworkFiles(projectPath: string, options: any): Promise<void> {
    this.options = options;
    
    // Ensure Vert.x-specific directory structure exists
    await this.createJavaDirectoryStructure(projectPath);
    
    // Call parent implementation
    await super.generateFrameworkFiles(projectPath, options);
  }

  protected getPackageName(): string {
    return `com.${this.sanitizeName(this.options?.name || 'example')}`;
  }

  protected getFrameworkDependencies(): Record<string, string> {
    return {
      'io.vertx:vertx-core': '',
      'io.vertx:vertx-web': '',
      'io.vertx:vertx-web-client': '',
      'io.vertx:vertx-auth-jwt': '',
      'io.vertx:vertx-pg-client': '',
      'io.vertx:vertx-sql-client-templates': '',
      'io.vertx:vertx-redis-client': '',
      'io.vertx:vertx-health-check': '',
      'io.vertx:vertx-micrometer-metrics': '',
      'io.vertx:vertx-openapi': '',
      'io.vertx:vertx-web-openapi': '',
      'io.vertx:vertx-json-schema': '',
      'io.vertx:vertx-mail-client': '',
      'io.vertx:vertx-eventbus-bridge-common': '',
      'io.vertx:vertx-service-discovery': '',
      'io.vertx:vertx-circuit-breaker': '',
      'io.vertx:vertx-config': '',
      'io.micrometer:micrometer-registry-prometheus': '',
      'org.postgresql:postgresql': '',
      'ch.qos.logback:logback-classic': 'runtime',
      'io.vertx:vertx-junit5': 'test',
      'org.testcontainers:postgresql': 'test',
      'com.h2database:h2': 'test'
    };
  }
  
  protected generatePomXml(): string {
    const groupId = `com.${this.sanitizeName(this.options?.name || 'example')}`;
    const artifactId = this.sanitizeName(this.options?.name || 'api');
    const frameworkDeps = this.getFrameworkDependencies();
    
    return `<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <groupId>${groupId}</groupId>
    <artifactId>${artifactId}</artifactId>
    <version>1.0.0</version>
    <name>${this.options?.name || 'Backend API'}</name>
    <description>Vert.x reactive backend service generated by Re-Shell</description>
    
    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <vertx.version>4.5.1</vertx.version>
        <junit.version>5.10.1</junit.version>
        <logback.version>1.4.14</logback.version>
        <micrometer.version>1.12.1</micrometer.version>
        <testcontainers.version>1.19.3</testcontainers.version>
        <main.verticle>${groupId}.verticle.MainVerticle</main.verticle>
        <launcher.class>io.vertx.core.Launcher</launcher.class>
    </properties>
    
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>io.vertx</groupId>
                <artifactId>vertx-stack-depchain</artifactId>
                <version>\${vertx.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    
    <dependencies>
        <!-- Vert.x Core -->
        <dependency>
            <groupId>io.vertx</groupId>
            <artifactId>vertx-core</artifactId>
        </dependency>
        <dependency>
            <groupId>io.vertx</groupId>
            <artifactId>vertx-web</artifactId>
        </dependency>
        <dependency>
            <groupId>io.vertx</groupId>
            <artifactId>vertx-web-client</artifactId>
        </dependency>
        
        <!-- Authentication -->
        <dependency>
            <groupId>io.vertx</groupId>
            <artifactId>vertx-auth-jwt</artifactId>
        </dependency>
        
        <!-- Database -->
        <dependency>
            <groupId>io.vertx</groupId>
            <artifactId>vertx-pg-client</artifactId>
        </dependency>
        <dependency>
            <groupId>io.vertx</groupId>
            <artifactId>vertx-sql-client-templates</artifactId>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
        </dependency>
        
        <!-- Redis -->
        <dependency>
            <groupId>io.vertx</groupId>
            <artifactId>vertx-redis-client</artifactId>
        </dependency>
        
        <!-- Health & Monitoring -->
        <dependency>
            <groupId>io.vertx</groupId>
            <artifactId>vertx-health-check</artifactId>
        </dependency>
        <dependency>
            <groupId>io.vertx</groupId>
            <artifactId>vertx-micrometer-metrics</artifactId>
        </dependency>
        <dependency>
            <groupId>io.micrometer</groupId>
            <artifactId>micrometer-registry-prometheus</artifactId>
            <version>\${micrometer.version}</version>
        </dependency>
        
        <!-- OpenAPI -->
        <dependency>
            <groupId>io.vertx</groupId>
            <artifactId>vertx-openapi</artifactId>
        </dependency>
        <dependency>
            <groupId>io.vertx</groupId>
            <artifactId>vertx-web-openapi</artifactId>
        </dependency>
        <dependency>
            <groupId>io.vertx</groupId>
            <artifactId>vertx-json-schema</artifactId>
        </dependency>
        
        <!-- Service Discovery -->
        <dependency>
            <groupId>io.vertx</groupId>
            <artifactId>vertx-service-discovery</artifactId>
        </dependency>
        <dependency>
            <groupId>io.vertx</groupId>
            <artifactId>vertx-circuit-breaker</artifactId>
        </dependency>
        
        <!-- Configuration -->
        <dependency>
            <groupId>io.vertx</groupId>
            <artifactId>vertx-config</artifactId>
        </dependency>
        
        <!-- Mail -->
        <dependency>
            <groupId>io.vertx</groupId>
            <artifactId>vertx-mail-client</artifactId>
        </dependency>
        
        <!-- Event Bus -->
        <dependency>
            <groupId>io.vertx</groupId>
            <artifactId>vertx-eventbus-bridge-common</artifactId>
        </dependency>
        
        <!-- Logging -->
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>\${logback.version}</version>
            <scope>runtime</scope>
        </dependency>
        
        <!-- Test Dependencies -->
        <dependency>
            <groupId>io.vertx</groupId>
            <artifactId>vertx-junit5</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-api</artifactId>
            <version>\${junit.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
            <version>\${junit.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>postgresql</artifactId>
            <version>\${testcontainers.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <release>17</release>
                </configuration>
            </plugin>
            <plugin>
                <groupId>io.reactiverse</groupId>
                <artifactId>vertx-maven-plugin</artifactId>
                <version>1.0.28</version>
                <executions>
                    <execution>
                        <id>vmp</id>
                        <goals>
                            <goal>initialize</goal>
                            <goal>package</goal>
                        </goals>
                    </execution>
                </executions>
                <configuration>
                    <redeploy>true</redeploy>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>3.5.1</version>
                <executions>
                    <execution>
                        <id>package-fat-jar</id>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                        <configuration>
                            <transformers>
                                <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                                    <manifestEntries>
                                        <Main-Class>\${launcher.class}</Main-Class>
                                        <Main-Verticle>\${main.verticle}</Main-Verticle>
                                    </manifestEntries>
                                </transformer>
                                <transformer implementation="org.apache.maven.plugins.shade.resource.ServicesResourceTransformer"/>
                            </transformers>
                            <filters>
                                <filter>
                                    <artifact>*:*</artifact>
                                    <excludes>
                                        <exclude>META-INF/*.SF</exclude>
                                        <exclude>META-INF/*.DSA</exclude>
                                        <exclude>META-INF/*.RSA</exclude>
                                    </excludes>
                                </filter>
                            </filters>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.2.2</version>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-failsafe-plugin</artifactId>
                <version>3.2.2</version>
            </plugin>
        </plugins>
    </build>
    
    <profiles>
        <profile>
            <id>native</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.graalvm.buildtools</groupId>
                        <artifactId>native-maven-plugin</artifactId>
                        <version>0.9.28</version>
                        <extensions>true</extensions>
                        <executions>
                            <execution>
                                <id>build-native</id>
                                <goals>
                                    <goal>compile-no-fork</goal>
                                </goals>
                                <phase>package</phase>
                            </execution>
                        </executions>
                        <configuration>
                            <fallback>false</fallback>
                            <buildArgs>
                                <buildArg>--verbose</buildArg>
                                <buildArg>--initialize-at-build-time=io.vertx.core.impl.logging.LoggerFactory</buildArg>
                            </buildArgs>
                        </configuration>
                    </plugin>
                </plugins>
            </build>
        </profile>
    </profiles>
</project>`;
  }

  protected generateApplicationProperties(): string {
    const dbName = this.sanitizeName(this.options?.name || 'example') + '_db';
    
    return `# Vert.x Application Configuration
http.port=${this.options?.port || 8080}
http.host=0.0.0.0

# Database Configuration
database.host=localhost
database.port=5432
database.name=${dbName}
database.user=postgres
database.password=password
database.pool.max_size=20

# JWT Configuration
jwt.secret=pleaseChangeThisSecretForProduction
jwt.expiration=3600

# Redis Configuration
redis.host=localhost
redis.port=6379

# Logging Configuration
logging.level=INFO
`;
  }

  protected generateApplicationYml(): string {
    const dbName = this.sanitizeName(this.options?.name || 'example') + '_db';
    
    return `http:
  port: ${this.options?.port || 8080}
  host: 0.0.0.0

database:
  host: localhost
  port: 5432
  name: ${dbName}
  user: postgres
  password: password
  pool:
    max_size: 20

jwt:
  secret: pleaseChangeThisSecretForProduction
  expiration: 3600

redis:
  host: localhost
  port: 6379

logging:
  level: INFO
`;
  }

  protected async generateFrameworkSpecificFiles(projectPath: string, options: any): Promise<void> {
    const packageName = this.getPackageName();
    const packagePath = this.getPackagePath();
    
    const files = [
      // Main Verticle
      {
        path: `src/main/java/${packagePath}/verticle/MainVerticle.java`,
        content: `package ${packageName}.verticle;

import ${packageName}.handler.*;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.handler.BodyHandler;
import io.vertx.ext.web.handler.CorsHandler;
import io.vertx.ext.web.handler.LoggerHandler;
import io.vertx.ext.web.openapi.RouterBuilder;
import io.vertx.pgclient.PgConnectOptions;
import io.vertx.pgclient.PgPool;
import io.vertx.sqlclient.PoolOptions;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MainVerticle extends AbstractVerticle {

  private static final Logger logger = LoggerFactory.getLogger(MainVerticle.class);
  private HttpServer server;
  private PgPool pgPool;

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    logger.info("Starting MainVerticle...");
    
    // Initialize database connection
    initDatabase()
      .compose(v -> setupRouter())
      .compose(this::startHttpServer)
      .onComplete(ar -> {
        if (ar.succeeded()) {
          logger.info("HTTP server started on port {}", config().getInteger("http.port", 8080));
          startPromise.complete();
        } else {
          logger.error("Failed to start server", ar.cause());
          startPromise.fail(ar.cause());
        }
      });
  }

  private Promise<Void> initDatabase() {
    Promise<Void> promise = Promise.promise();
    
    JsonObject config = config();
    PgConnectOptions connectOptions = new PgConnectOptions()
      .setPort(config.getInteger("database.port", 5432))
      .setHost(config.getString("database.host", "localhost"))
      .setDatabase(config.getString("database.name", "${this.sanitizeName(this.options?.name || 'example')}_db"))
      .setUser(config.getString("database.user", "postgres"))
      .setPassword(config.getString("database.password", "password"));

    PoolOptions poolOptions = new PoolOptions()
      .setMaxSize(config.getInteger("database.pool.max_size", 20));

    pgPool = PgPool.pool(vertx, connectOptions, poolOptions);
    
    // Test database connection
    pgPool.getConnection(ar -> {
      if (ar.succeeded()) {
        ar.result().close();
        logger.info("Database connection established");
        promise.complete();
      } else {
        logger.error("Failed to connect to database", ar.cause());
        promise.fail(ar.cause());
      }
    });
    
    return promise;
  }

  private Promise<Router> setupRouter() {
    Promise<Router> promise = Promise.promise();
    
    Router router = Router.router(vertx);
    
    // Global middleware
    router.route().handler(LoggerHandler.create());
    router.route().handler(BodyHandler.create());
    router.route().handler(CorsHandler.create("*")
      .allowedMethod(io.vertx.core.http.HttpMethod.GET)
      .allowedMethod(io.vertx.core.http.HttpMethod.POST)
      .allowedMethod(io.vertx.core.http.HttpMethod.PUT)
      .allowedMethod(io.vertx.core.http.HttpMethod.DELETE)
      .allowedMethod(io.vertx.core.http.HttpMethod.PATCH)
      .allowedMethod(io.vertx.core.http.HttpMethod.OPTIONS)
      .allowedHeader("*")
      .allowCredentials(true));
    
    // Initialize handlers
    AuthHandler authHandler = new AuthHandler(vertx, pgPool);
    UserHandler userHandler = new UserHandler(vertx, pgPool);
    HealthHandler healthHandler = new HealthHandler(vertx);
    
    // Setup routes
    setupAuthRoutes(router, authHandler);
    setupUserRoutes(router, userHandler);
    setupHealthRoutes(router, healthHandler);
    
    // Error handling
    router.errorHandler(404, ctx -> {
      ctx.response()
        .setStatusCode(404)
        .putHeader("content-type", "application/json")
        .end(new JsonObject()
          .put("error", "Not Found")
          .put("message", "The requested resource was not found")
          .put("path", ctx.request().path())
          .encode());
    });
    
    router.errorHandler(500, ctx -> {
      logger.error("Internal server error", ctx.failure());
      ctx.response()
        .setStatusCode(500)
        .putHeader("content-type", "application/json")
        .end(new JsonObject()
          .put("error", "Internal Server Error")
          .put("message", "An unexpected error occurred")
          .encode());
    });
    
    promise.complete(router);
    return promise;
  }
  
  private void setupAuthRoutes(Router router, AuthHandler authHandler) {
    router.post("/api/v1/auth/register").handler(authHandler::register);
    router.post("/api/v1/auth/login").handler(authHandler::login);
    router.post("/api/v1/auth/refresh").handler(authHandler::refresh);
    router.post("/api/v1/auth/logout").handler(authHandler::logout);
  }
  
  private void setupUserRoutes(Router router, UserHandler userHandler) {
    router.get("/api/v1/users").handler(userHandler::getAllUsers);
    router.get("/api/v1/users/me").handler(userHandler::getCurrentUser);
    router.get("/api/v1/users/:id").handler(userHandler::getUserById);
    router.put("/api/v1/users/:id").handler(userHandler::updateUser);
    router.put("/api/v1/users/:id/password").handler(userHandler::changePassword);
    router.delete("/api/v1/users/:id").handler(userHandler::deleteUser);
  }
  
  private void setupHealthRoutes(Router router, HealthHandler healthHandler) {
    router.get("/api/v1/health").handler(healthHandler::health);
    router.get("/api/v1/health/ready").handler(healthHandler::ready);
    router.get("/api/v1/health/live").handler(healthHandler::live);
  }

  private Promise<HttpServer> startHttpServer(Router router) {
    Promise<HttpServer> promise = Promise.promise();
    
    int port = config().getInteger("http.port", 8080);
    server = vertx.createHttpServer()
      .requestHandler(router)
      .listen(port, ar -> {
        if (ar.succeeded()) {
          promise.complete(ar.result());
        } else {
          promise.fail(ar.cause());
        }
      });
    
    return promise;
  }

  @Override
  public void stop(Promise<Void> stopPromise) throws Exception {
    logger.info("Stopping MainVerticle...");
    
    if (server != null) {
      server.close(ar -> {
        if (pgPool != null) {
          pgPool.close();
        }
        stopPromise.complete();
      });
    } else {
      stopPromise.complete();
    }
  }
}`
      },

      // Handlers
      {
        path: `src/main/java/${packagePath}/handler/AuthHandler.java`,
        content: `package ${packageName}.handler;

import ${packageName}.service.AuthService;
import ${packageName}.service.UserService;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.RoutingContext;
import io.vertx.sqlclient.Pool;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class AuthHandler {
  
  private static final Logger logger = LoggerFactory.getLogger(AuthHandler.class);
  private final AuthService authService;
  private final UserService userService;
  
  public AuthHandler(Vertx vertx, Pool pool) {
    this.userService = new UserService(vertx, pool);
    this.authService = new AuthService(vertx, userService);
  }
  
  public void register(RoutingContext ctx) {
    JsonObject body = ctx.getBodyAsJson();
    
    if (body == null || !isValidRegistration(body)) {
      ctx.response()
        .setStatusCode(400)
        .putHeader("content-type", "application/json")
        .end(new JsonObject()
          .put("error", "Bad Request")
          .put("message", "Invalid registration data")
          .encode());
      return;
    }
    
    authService.register(body)
      .onSuccess(result -> {
        ctx.response()
          .setStatusCode(201)
          .putHeader("content-type", "application/json")
          .end(result.encode());
      })
      .onFailure(error -> {
        logger.error("Registration failed", error);
        ctx.response()
          .setStatusCode(409)
          .putHeader("content-type", "application/json")
          .end(new JsonObject()
            .put("error", "Conflict")
            .put("message", error.getMessage())
            .encode());
      });
  }
  
  public void login(RoutingContext ctx) {
    JsonObject body = ctx.getBodyAsJson();
    
    if (body == null || !isValidLogin(body)) {
      ctx.response()
        .setStatusCode(400)
        .putHeader("content-type", "application/json")
        .end(new JsonObject()
          .put("error", "Bad Request")
          .put("message", "Invalid login data")
          .encode());
      return;
    }
    
    authService.login(body)
      .onSuccess(result -> {
        ctx.response()
          .setStatusCode(200)
          .putHeader("content-type", "application/json")
          .end(result.encode());
      })
      .onFailure(error -> {
        logger.error("Login failed", error);
        ctx.response()
          .setStatusCode(401)
          .putHeader("content-type", "application/json")
          .end(new JsonObject()
            .put("error", "Unauthorized")
            .put("message", "Invalid credentials")
            .encode());
      });
  }
  
  public void refresh(RoutingContext ctx) {
    String authorization = ctx.request().getHeader("Authorization");
    
    if (authorization == null || !authorization.startsWith("Bearer ")) {
      ctx.response()
        .setStatusCode(401)
        .putHeader("content-type", "application/json")
        .end(new JsonObject()
          .put("error", "Unauthorized")
          .put("message", "Missing or invalid authorization header")
          .encode());
      return;
    }
    
    String token = authorization.substring(7);
    
    authService.refreshToken(token)
      .onSuccess(result -> {
        ctx.response()
          .setStatusCode(200)
          .putHeader("content-type", "application/json")
          .end(result.encode());
      })
      .onFailure(error -> {
        logger.error("Token refresh failed", error);
        ctx.response()
          .setStatusCode(401)
          .putHeader("content-type", "application/json")
          .end(new JsonObject()
            .put("error", "Unauthorized")
            .put("message", "Invalid refresh token")
            .encode());
      });
  }
  
  public void logout(RoutingContext ctx) {
    // For JWT-based auth, logout is typically handled client-side
    // Here we could implement token blacklisting if needed
    ctx.response()
      .setStatusCode(200)
      .putHeader("content-type", "application/json")
      .end(new JsonObject()
        .put("message", "Logged out successfully")
        .encode());
  }
  
  private boolean isValidRegistration(JsonObject body) {
    return body.containsKey("firstName") && 
           body.containsKey("lastName") &&
           body.containsKey("email") && 
           body.containsKey("password") &&
           body.getString("email").contains("@");
  }
  
  private boolean isValidLogin(JsonObject body) {
    return body.containsKey("email") && 
           body.containsKey("password") &&
           body.getString("email").contains("@");
  }
}`
      },

      {
        path: `src/main/java/${packagePath}/handler/UserHandler.java`,
        content: `package ${packageName}.handler;

import ${packageName}.service.UserService;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.RoutingContext;
import io.vertx.sqlclient.Pool;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class UserHandler {
  
  private static final Logger logger = LoggerFactory.getLogger(UserHandler.class);
  private final UserService userService;
  
  public UserHandler(Vertx vertx, Pool pool) {
    this.userService = new UserService(vertx, pool);
  }
  
  public void getAllUsers(RoutingContext ctx) {
    int page = getIntParam(ctx, "page", 0);
    int size = getIntParam(ctx, "size", 10);
    
    userService.getAllUsers(page, size)
      .onSuccess(result -> {
        ctx.response()
          .setStatusCode(200)
          .putHeader("content-type", "application/json")
          .end(result.encode());
      })
      .onFailure(error -> {
        logger.error("Failed to get users", error);
        ctx.response()
          .setStatusCode(500)
          .putHeader("content-type", "application/json")
          .end(new JsonObject()
            .put("error", "Internal Server Error")
            .put("message", "Failed to retrieve users")
            .encode());
      });
  }
  
  public void getCurrentUser(RoutingContext ctx) {
    // TODO: Extract user from JWT token
    String userEmail = "current@user.com"; // Placeholder
    
    userService.getUserByEmail(userEmail)
      .onSuccess(result -> {
        if (result != null) {
          ctx.response()
            .setStatusCode(200)
            .putHeader("content-type", "application/json")
            .end(result.encode());
        } else {
          ctx.response()
            .setStatusCode(404)
            .putHeader("content-type", "application/json")
            .end(new JsonObject()
              .put("error", "Not Found")
              .put("message", "User not found")
              .encode());
        }
      })
      .onFailure(error -> {
        logger.error("Failed to get current user", error);
        ctx.response()
          .setStatusCode(500)
          .putHeader("content-type", "application/json")
          .end(new JsonObject()
            .put("error", "Internal Server Error")
            .put("message", "Failed to retrieve user")
            .encode());
      });
  }
  
  public void getUserById(RoutingContext ctx) {
    String userId = ctx.pathParam("id");
    
    if (userId == null) {
      ctx.response()
        .setStatusCode(400)
        .putHeader("content-type", "application/json")
        .end(new JsonObject()
          .put("error", "Bad Request")
          .put("message", "User ID is required")
          .encode());
      return;
    }
    
    userService.getUserById(userId)
      .onSuccess(result -> {
        if (result != null) {
          ctx.response()
            .setStatusCode(200)
            .putHeader("content-type", "application/json")
            .end(result.encode());
        } else {
          ctx.response()
            .setStatusCode(404)
            .putHeader("content-type", "application/json")
            .end(new JsonObject()
              .put("error", "Not Found")
              .put("message", "User not found")
              .encode());
        }
      })
      .onFailure(error -> {
        logger.error("Failed to get user by ID", error);
        ctx.response()
          .setStatusCode(500)
          .putHeader("content-type", "application/json")
          .end(new JsonObject()
            .put("error", "Internal Server Error")
            .put("message", "Failed to retrieve user")
            .encode());
      });
  }
  
  public void updateUser(RoutingContext ctx) {
    String userId = ctx.pathParam("id");
    JsonObject body = ctx.getBodyAsJson();
    
    if (userId == null || body == null) {
      ctx.response()
        .setStatusCode(400)
        .putHeader("content-type", "application/json")
        .end(new JsonObject()
          .put("error", "Bad Request")
          .put("message", "User ID and update data are required")
          .encode());
      return;
    }
    
    userService.updateUser(userId, body)
      .onSuccess(result -> {
        if (result != null) {
          ctx.response()
            .setStatusCode(200)
            .putHeader("content-type", "application/json")
            .end(result.encode());
        } else {
          ctx.response()
            .setStatusCode(404)
            .putHeader("content-type", "application/json")
            .end(new JsonObject()
              .put("error", "Not Found")
              .put("message", "User not found")
              .encode());
        }
      })
      .onFailure(error -> {
        logger.error("Failed to update user", error);
        ctx.response()
          .setStatusCode(500)
          .putHeader("content-type", "application/json")
          .end(new JsonObject()
            .put("error", "Internal Server Error")
            .put("message", "Failed to update user")
            .encode());
      });
  }
  
  public void changePassword(RoutingContext ctx) {
    String userId = ctx.pathParam("id");
    JsonObject body = ctx.getBodyAsJson();
    
    if (userId == null || body == null || !body.containsKey("currentPassword") || !body.containsKey("newPassword")) {
      ctx.response()
        .setStatusCode(400)
        .putHeader("content-type", "application/json")
        .end(new JsonObject()
          .put("error", "Bad Request")
          .put("message", "User ID, current password, and new password are required")
          .encode());
      return;
    }
    
    userService.changePassword(userId, body.getString("currentPassword"), body.getString("newPassword"))
      .onSuccess(result -> {
        ctx.response()
          .setStatusCode(200)
          .putHeader("content-type", "application/json")
          .end(new JsonObject()
            .put("message", "Password changed successfully")
            .encode());
      })
      .onFailure(error -> {
        logger.error("Failed to change password", error);
        ctx.response()
          .setStatusCode(400)
          .putHeader("content-type", "application/json")
          .end(new JsonObject()
            .put("error", "Bad Request")
            .put("message", "Failed to change password")
            .encode());
      });
  }
  
  public void deleteUser(RoutingContext ctx) {
    String userId = ctx.pathParam("id");
    
    if (userId == null) {
      ctx.response()
        .setStatusCode(400)
        .putHeader("content-type", "application/json")
        .end(new JsonObject()
          .put("error", "Bad Request")
          .put("message", "User ID is required")
          .encode());
      return;
    }
    
    userService.deleteUser(userId)
      .onSuccess(result -> {
        ctx.response()
          .setStatusCode(204)
          .end();
      })
      .onFailure(error -> {
        logger.error("Failed to delete user", error);
        ctx.response()
          .setStatusCode(500)
          .putHeader("content-type", "application/json")
          .end(new JsonObject()
            .put("error", "Internal Server Error")
            .put("message", "Failed to delete user")
            .encode());
      });
  }
  
  private int getIntParam(RoutingContext ctx, String param, int defaultValue) {
    String value = ctx.request().getParam(param);
    if (value != null) {
      try {
        return Integer.parseInt(value);
      } catch (NumberFormatException e) {
        return defaultValue;
      }
    }
    return defaultValue;
  }
}`
      },

      {
        path: `src/main/java/${packagePath}/handler/HealthHandler.java`,
        content: `package ${packageName}.handler;

import io.vertx.core.Vertx;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.RoutingContext;

import java.time.LocalDateTime;

public class HealthHandler {
  
  private final Vertx vertx;
  
  public HealthHandler(Vertx vertx) {
    this.vertx = vertx;
  }
  
  public void health(RoutingContext ctx) {
    JsonObject response = new JsonObject()
      .put("status", "UP")
      .put("timestamp", LocalDateTime.now().toString())
      .put("service", "${this.options?.name || 'backend-api'}")
      .put("version", "1.0.0")
      .put("vertx_version", System.getProperty("vertx.version", "4.5.1"));
    
    ctx.response()
      .setStatusCode(200)
      .putHeader("content-type", "application/json")
      .end(response.encode());
  }
  
  public void ready(RoutingContext ctx) {
    JsonObject response = new JsonObject()
      .put("status", "READY");
    
    ctx.response()
      .setStatusCode(200)
      .putHeader("content-type", "application/json")
      .end(response.encode());
  }
  
  public void live(RoutingContext ctx) {
    JsonObject response = new JsonObject()
      .put("status", "ALIVE");
    
    ctx.response()
      .setStatusCode(200)
      .putHeader("content-type", "application/json")
      .end(response.encode());
  }
}`
      },

      // Services
      {
        path: `src/main/java/${packagePath}/service/AuthService.java`,
        content: `package ${packageName}.service;

import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.auth.jwt.JWTAuth;
import io.vertx.ext.auth.jwt.JWTAuthOptions;
import io.vertx.ext.jwt.JWTOptions;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.security.SecureRandom;
import java.util.Base64;
import java.util.UUID;

public class AuthService {
  
  private static final Logger logger = LoggerFactory.getLogger(AuthService.class);
  private final Vertx vertx;
  private final UserService userService;
  private final JWTAuth jwtAuth;
  
  public AuthService(Vertx vertx, UserService userService) {
    this.vertx = vertx;
    this.userService = userService;
    
    // Initialize JWT auth
    String secret = System.getProperty("jwt.secret", "pleaseChangeThisSecretForProduction");
    JWTAuthOptions jwtOptions = new JWTAuthOptions()
      .addJwk(new JsonObject()
        .put("kty", "oct")
        .put("k", Base64.getEncoder().encodeToString(secret.getBytes())));
    
    this.jwtAuth = JWTAuth.create(vertx, jwtOptions);
  }
  
  public Future<JsonObject> register(JsonObject registrationData) {
    Promise<JsonObject> promise = Promise.promise();
    
    String email = registrationData.getString("email");
    
    // Check if user already exists
    userService.getUserByEmail(email)
      .onComplete(ar -> {
        if (ar.succeeded() && ar.result() != null) {
          promise.fail(new RuntimeException("User with email " + email + " already exists"));
        } else {
          // Create new user
          JsonObject userData = new JsonObject()
            .put("id", UUID.randomUUID().toString())
            .put("firstName", registrationData.getString("firstName"))
            .put("lastName", registrationData.getString("lastName"))
            .put("email", email)
            .put("password", hashPassword(registrationData.getString("password")))
            .put("role", "USER")
            .put("createdAt", System.currentTimeMillis())
            .put("updatedAt", System.currentTimeMillis());
          
          userService.createUser(userData)
            .onSuccess(user -> {
              String accessToken = generateAccessToken(user);
              String refreshToken = generateRefreshToken(user);
              
              JsonObject response = new JsonObject()
                .put("accessToken", accessToken)
                .put("refreshToken", refreshToken)
                .put("tokenType", "Bearer")
                .put("expiresIn", 3600)
                .put("user", sanitizeUser(user));
              
              promise.complete(response);
            })
            .onFailure(promise::fail);
        }
      });
    
    return promise.future();
  }
  
  public Future<JsonObject> login(JsonObject loginData) {
    Promise<JsonObject> promise = Promise.promise();
    
    String email = loginData.getString("email");
    String password = loginData.getString("password");
    
    userService.getUserByEmail(email)
      .onComplete(ar -> {
        if (ar.succeeded() && ar.result() != null) {
          JsonObject user = ar.result();
          if (verifyPassword(password, user.getString("password"))) {
            String accessToken = generateAccessToken(user);
            String refreshToken = generateRefreshToken(user);
            
            JsonObject response = new JsonObject()
              .put("accessToken", accessToken)
              .put("refreshToken", refreshToken)
              .put("tokenType", "Bearer")
              .put("expiresIn", 3600)
              .put("user", sanitizeUser(user));
            
            promise.complete(response);
          } else {
            promise.fail(new RuntimeException("Invalid credentials"));
          }
        } else {
          promise.fail(new RuntimeException("Invalid credentials"));
        }
      });
    
    return promise.future();
  }
  
  public Future<JsonObject> refreshToken(String refreshToken) {
    Promise<JsonObject> promise = Promise.promise();
    
    // Validate refresh token and get user
    jwtAuth.authenticate(new JsonObject().put("jwt", refreshToken))
      .onComplete(ar -> {
        if (ar.succeeded()) {
          JsonObject user = ar.result().principal();
          String newAccessToken = generateAccessToken(user);
          String newRefreshToken = generateRefreshToken(user);
          
          JsonObject response = new JsonObject()
            .put("accessToken", newAccessToken)
            .put("refreshToken", newRefreshToken)
            .put("tokenType", "Bearer")
            .put("expiresIn", 3600)
            .put("user", sanitizeUser(user));
          
          promise.complete(response);
        } else {
          promise.fail(new RuntimeException("Invalid refresh token"));
        }
      });
    
    return promise.future();
  }
  
  private String generateAccessToken(JsonObject user) {
    return jwtAuth.generateToken(
      new JsonObject()
        .put("sub", user.getString("email"))
        .put("userId", user.getString("id"))
        .put("role", user.getString("role"))
        .put("type", "access"),
      new JWTOptions()
        .setExpiresInSeconds(3600)
        .setIssuer("${this.options?.name || 'backend-api'}")
    );
  }
  
  private String generateRefreshToken(JsonObject user) {
    return jwtAuth.generateToken(
      new JsonObject()
        .put("sub", user.getString("email"))
        .put("userId", user.getString("id"))
        .put("type", "refresh"),
      new JWTOptions()
        .setExpiresInSeconds(3600 * 24 * 7) // 7 days
        .setIssuer("${this.options?.name || 'backend-api'}")
    );
  }
  
  private String hashPassword(String password) {
    // Simple hash for demo - use bcrypt in production
    return Integer.toString(password.hashCode());
  }
  
  private boolean verifyPassword(String password, String hashedPassword) {
    return Integer.toString(password.hashCode()).equals(hashedPassword);
  }
  
  private JsonObject sanitizeUser(JsonObject user) {
    return new JsonObject()
      .put("id", user.getString("id"))
      .put("firstName", user.getString("firstName"))
      .put("lastName", user.getString("lastName"))
      .put("email", user.getString("email"))
      .put("role", user.getString("role"))
      .put("createdAt", user.getLong("createdAt"))
      .put("updatedAt", user.getLong("updatedAt"));
  }
}`
      },

      // Configuration
      {
        path: `conf/config.json`,
        content: `{
  "http.port": ${this.options?.port || 8080},
  "http.host": "0.0.0.0",
  "database.host": "localhost",
  "database.port": 5432,
  "database.name": "${this.sanitizeName(this.options?.name || 'example')}_db",
  "database.user": "postgres",
  "database.password": "password",
  "database.pool.max_size": 20,
  "jwt.secret": "pleaseChangeThisSecretForProduction",
  "jwt.expiration": 3600,
  "redis.host": "localhost",
  "redis.port": 6379,
  "logging.level": "INFO"
}`
      },

      // Test configuration
      {
        path: `src/test/resources/config-test.json`,
        content: `{
  "http.port": 0,
  "http.host": "localhost",
  "database.host": "localhost",
  "database.port": 5432,
  "database.name": "${this.sanitizeName(this.options?.name || 'example')}_test",
  "database.user": "postgres",
  "database.password": "password",
  "database.pool.max_size": 5,
  "jwt.secret": "test-secret-key",
  "jwt.expiration": 3600,
  "logging.level": "DEBUG"
}`
      },

      // Integration test
      {
        path: `src/test/java/${packagePath}/integration/MainVerticleTest.java`,
        content: `package ${packageName}.integration;

import ${packageName}.verticle.MainVerticle;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.client.WebClient;
import io.vertx.ext.web.codec.BodyCodec;
import io.vertx.junit5.VertxExtension;
import io.vertx.junit5.VertxTestContext;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(VertxExtension.class)
public class MainVerticleTest {

  private WebClient client;
  private int port;

  @BeforeEach
  void setup(Vertx vertx, VertxTestContext testContext) {
    client = WebClient.create(vertx);
    
    JsonObject config = new JsonObject()
      .put("http.port", 0) // Random available port
      .put("database.host", "localhost")
      .put("database.name", "test_db")
      .put("jwt.secret", "test-secret");
    
    vertx.deployVerticle(new MainVerticle(), 
      new io.vertx.core.DeploymentOptions().setConfig(config))
      .onComplete(testContext.succeeding(id -> {
        // Get the actual port the server started on
        port = vertx.sharedData().getLocalMap("server").get("port");
        testContext.completeNow();
      }));
  }

  @Test
  void testHealthEndpoint(Vertx vertx, VertxTestContext testContext) {
    client.get(port, "localhost", "/api/v1/health")
      .as(BodyCodec.jsonObject())
      .send()
      .onComplete(testContext.succeeding(response -> testContext.verify(() -> {
        assertEquals(200, response.statusCode());
        JsonObject body = response.body();
        assertNotNull(body);
        assertEquals("UP", body.getString("status"));
        assertTrue(body.containsKey("timestamp"));
        testContext.completeNow();
      })));
  }

  @Test
  void testUserRegistrationAndLogin(Vertx vertx, VertxTestContext testContext) {
    JsonObject registrationData = new JsonObject()
      .put("firstName", "John")
      .put("lastName", "Doe")
      .put("email", "john.doe@example.com")
      .put("password", "password123");

    // Test registration
    client.post(port, "localhost", "/api/v1/auth/register")
      .as(BodyCodec.jsonObject())
      .sendJsonObject(registrationData)
      .onComplete(testContext.succeeding(registerResponse -> testContext.verify(() -> {
        assertEquals(201, registerResponse.statusCode());
        JsonObject registerBody = registerResponse.body();
        assertNotNull(registerBody);
        assertTrue(registerBody.containsKey("accessToken"));
        assertTrue(registerBody.containsKey("refreshToken"));

        // Test login
        JsonObject loginData = new JsonObject()
          .put("email", "john.doe@example.com")
          .put("password", "password123");

        client.post(port, "localhost", "/api/v1/auth/login")
          .as(BodyCodec.jsonObject())
          .sendJsonObject(loginData)
          .onComplete(testContext.succeeding(loginResponse -> testContext.verify(() -> {
            assertEquals(200, loginResponse.statusCode());
            JsonObject loginBody = loginResponse.body();
            assertNotNull(loginBody);
            assertTrue(loginBody.containsKey("accessToken"));
            assertTrue(loginBody.containsKey("refreshToken"));
            testContext.completeNow();
          })));
      })));
  }
}`
      }
    ];

    // Write all files
    for (const file of files) {
      await fs.writeFile(path.join(projectPath, file.path), file.content);
    }
  }
}