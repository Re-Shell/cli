import { JavaBackendGenerator } from './java-base-generator';
import { promises as fs } from 'fs';
import * as path from 'path';

export class QuarkusGenerator extends JavaBackendGenerator {
  constructor() {
    super('Quarkus');
  }

  protected async createJavaDirectoryStructure(projectPath: string): Promise<void> {
    const packagePath = this.getPackagePath();
    
    const directories = [
      'src/main/java',
      `src/main/java/${packagePath}`,
      `src/main/java/${packagePath}/api`,
      `src/main/java/${packagePath}/api/resource`,
      `src/main/java/${packagePath}/api/dto`,
      `src/main/java/${packagePath}/service`,
      `src/main/java/${packagePath}/repository`,
      `src/main/java/${packagePath}/model`,
      `src/main/java/${packagePath}/dto`,
      `src/main/java/${packagePath}/controller`,
      `src/main/java/${packagePath}/config`,
      `src/main/java/${packagePath}/security`,
      `src/main/java/${packagePath}/exception`,
      `src/main/java/${packagePath}/util`,
      'src/main/resources',
      'src/main/resources/db',
      'src/main/resources/db/migration',
      'src/test/java',
      `src/test/java/${packagePath}`,
      `src/test/java/${packagePath}/api`,
      `src/test/java/${packagePath}/api/resource`,
      `src/test/java/${packagePath}/controller`,
      `src/test/java/${packagePath}/service`,
      `src/test/java/${packagePath}/integration`,
      'src/test/resources',
      'target',
      '.mvn',
      '.mvn/wrapper'
    ];

    for (const dir of directories) {
      await fs.mkdir(path.join(projectPath, dir), { recursive: true });
    }
  }
  
  protected async generateFrameworkFiles(projectPath: string, options: any): Promise<void> {
    this.options = options;
    
    // Ensure Quarkus-specific directory structure exists
    await this.createJavaDirectoryStructure(projectPath);
    
    // Call parent implementation
    await super.generateFrameworkFiles(projectPath, options);
  }

  protected getPackageName(): string {
    return `com.${this.sanitizeName(this.options?.name || 'example')}`;
  }

  protected getFrameworkDependencies(): Record<string, string> {
    return {
      'io.quarkus:quarkus-resteasy-reactive-jackson': '',
      'io.quarkus:quarkus-hibernate-orm-panache': '',
      'io.quarkus:quarkus-jdbc-postgresql': '',
      'io.quarkus:quarkus-security-jpa': '',
      'io.quarkus:quarkus-smallrye-jwt': '',
      'io.quarkus:quarkus-redis-client': '',
      'io.quarkus:quarkus-smallrye-openapi': '',
      'io.quarkus:quarkus-smallrye-health': '',
      'io.quarkus:quarkus-micrometer-registry-prometheus': '',
      'io.quarkus:quarkus-websockets': '',
      'io.quarkus:quarkus-mailer': '',
      'io.quarkus:quarkus-cache': '',
      'io.quarkus:quarkus-hibernate-validator': '',
      'io.quarkus:quarkus-flyway': '',
      'io.quarkus:quarkus-container-image-docker': ''
    };
  }
  
  protected generatePomXml(): string {
    const groupId = `com.${this.sanitizeName(this.options?.name || 'example')}`;
    const artifactId = this.sanitizeName(this.options?.name || 'api');
    const frameworkDeps = this.getFrameworkDependencies();
    
    return `<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <groupId>${groupId}</groupId>
    <artifactId>${artifactId}</artifactId>
    <version>1.0.0</version>
    <name>${this.options?.name || 'Backend API'}</name>
    <description>Quarkus backend service generated by Re-Shell</description>
    
    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <quarkus.platform.group-id>io.quarkus.platform</quarkus.platform.group-id>
        <quarkus.platform.artifact-id>quarkus-bom</quarkus.platform.artifact-id>
        <quarkus.platform.version>3.6.0</quarkus.platform.version>
        <skipITs>true</skipITs>
        <surefire-plugin.version>3.0.0</surefire-plugin.version>
    </properties>
    
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>\${quarkus.platform.group-id}</groupId>
                <artifactId>\${quarkus.platform.artifact-id}</artifactId>
                <version>\${quarkus.platform.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    
    <dependencies>
        <!-- Quarkus Core -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-arc</artifactId>
        </dependency>
        
        <!-- REST -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-resteasy-reactive</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-resteasy-reactive-jackson</artifactId>
        </dependency>
        
        <!-- Database -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-hibernate-orm-panache</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-jdbc-postgresql</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-flyway</artifactId>
        </dependency>
        
        <!-- Security -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-security-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-smallrye-jwt</artifactId>
        </dependency>
        
        <!-- Redis -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-redis-client</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-cache</artifactId>
        </dependency>
        
        <!-- Validation -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-hibernate-validator</artifactId>
        </dependency>
        
        <!-- Monitoring -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-smallrye-health</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-micrometer-registry-prometheus</artifactId>
        </dependency>
        
        <!-- Documentation -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-smallrye-openapi</artifactId>
        </dependency>
        
        <!-- WebSocket -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-websockets</artifactId>
        </dependency>
        
        <!-- Email */
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-mailer</artifactId>
        </dependency>
        
        <!-- Container Image -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-container-image-docker</artifactId>
        </dependency>
        
        <!-- Test -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-junit5</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.rest-assured</groupId>
            <artifactId>rest-assured</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-test-h2</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>1.19.1</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>postgresql</artifactId>
            <version>1.19.1</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>\${quarkus.platform.group-id}</groupId>
                <artifactId>quarkus-maven-plugin</artifactId>
                <version>\${quarkus.platform.version}</version>
                <extensions>true</extensions>
                <executions>
                    <execution>
                        <goals>
                            <goal>build</goal>
                            <goal>generate-code</goal>
                            <goal>generate-code-tests</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <compilerArgs>
                        <arg>-parameters</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
            <plugin>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>\${surefire-plugin.version}</version>
                <configuration>
                    <systemPropertyVariables>
                        <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>
                        <maven.home>\${maven.home}</maven.home>
                    </systemPropertyVariables>
                </configuration>
            </plugin>
            <plugin>
                <artifactId>maven-failsafe-plugin</artifactId>
                <version>\${surefire-plugin.version}</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>integration-test</goal>
                            <goal>verify</goal>
                        </goals>
                        <configuration>
                            <systemPropertyVariables>
                                <native.image.path>\${project.build.directory}/\${project.build.finalName}-runner</native.image.path>
                                <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>
                                <maven.home>\${maven.home}</maven.home>
                            </systemPropertyVariables>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
    
    <profiles>
        <profile>
            <id>native</id>
            <activation>
                <property>
                    <name>native</name>
                </property>
            </activation>
            <properties>
                <skipITs>false</skipITs>
                <quarkus.package.type>native</quarkus.package.type>
            </properties>
        </profile>
    </profiles>
</project>`;
  }
  
  protected generateApplicationProperties(): string {
    return `# Application Configuration
quarkus.application.name=${this.options?.name || 'backend-api'}
quarkus.http.port=${this.options?.port || 8080}
quarkus.profile=dev

# Database Configuration
quarkus.datasource.db-kind=postgresql
quarkus.datasource.username=\${DATABASE_USER:postgres}
quarkus.datasource.password=\${DATABASE_PASSWORD:password}
quarkus.datasource.reactive.url=\${DATABASE_URL:postgresql://localhost:5432/${this.sanitizeName(this.options?.name || 'backend')}_db}

# Hibernate ORM Configuration
quarkus.hibernate-orm.database.generation=validate
quarkus.hibernate-orm.log.sql=false
quarkus.hibernate-orm.log.format-sql=true

# Flyway Configuration
quarkus.flyway.migrate-at-start=true
quarkus.flyway.locations=db/migration
quarkus.flyway.baseline-on-migrate=true

# Redis Configuration
quarkus.redis.hosts=\${REDIS_URL:redis://localhost:6379}
quarkus.redis.password=\${REDIS_PASSWORD:}
quarkus.redis.timeout=60s

# JWT Configuration
mp.jwt.verify.publickey.location=META-INF/publicKey.pem
mp.jwt.verify.issuer=\${JWT_ISSUER:https://example.com}
smallrye.jwt.sign.key.location=META-INF/privateKey.pem
quarkus.smallrye-jwt.enabled=true

# Email Configuration
quarkus.mailer.host=\${SMTP_HOST:smtp.gmail.com}
quarkus.mailer.port=\${SMTP_PORT:587}
quarkus.mailer.username=\${SMTP_USER:}
quarkus.mailer.password=\${SMTP_PASS:}
quarkus.mailer.start-tls=REQUIRED
quarkus.mailer.from=\${SMTP_FROM:noreply@example.com}

# Health Check Configuration
quarkus.health.extensions.enabled=true
quarkus.health.openapi.included=true

# Metrics Configuration
quarkus.micrometer.enabled=true
quarkus.micrometer.registry-enabled-default=true
quarkus.micrometer.export.prometheus.enabled=true

# OpenAPI Configuration
quarkus.swagger-ui.always-include=true
quarkus.swagger-ui.path=/swagger-ui
mp.openapi.extensions.smallrye.info.title=${this.options?.name || 'Backend API'}
mp.openapi.extensions.smallrye.info.version=1.0.0
mp.openapi.extensions.smallrye.info.description=Quarkus backend service API
mp.openapi.extensions.smallrye.info.contact.email=support@example.com
mp.openapi.extensions.smallrye.info.license.name=MIT

# Logging Configuration
quarkus.log.console.enable=true
quarkus.log.console.format=%d{HH:mm:ss} %-5p [%c{2.}] (%t) %s%e%n
quarkus.log.console.level=INFO
quarkus.log.category."io.quarkus.security".level=DEBUG

# Development Configuration
%dev.quarkus.live-reload.instrumentation=true
%dev.quarkus.log.console.color=true

# Native Configuration
quarkus.native.resources.includes=db/migration/**
quarkus.native.additional-build-args=--initialize-at-run-time=org.postgresql.Driver

# Container Image Configuration
quarkus.container-image.build=true
quarkus.container-image.registry=
quarkus.container-image.group=
quarkus.container-image.name=${this.sanitizeName(this.options?.name || 'backend-api')}
quarkus.container-image.tag=latest`;
  }
  
  protected async generateFrameworkSpecificFiles(projectPath: string, options: any): Promise<void> {
    const packageName = this.getPackageName();
    const packagePath = this.getPackagePath();
    
    // Generate main application class (Quarkus doesn't need one, but we'll create a startup bean)
    await fs.writeFile(
      path.join(projectPath, 'src/main/java', packagePath, 'ApplicationLifecycle.java'),
      this.generateApplicationLifecycle()
    );
    
    // Generate JAX-RS resources (controllers)
    const resourceFiles = this.generateResourceFiles();
    for (const file of resourceFiles) {
      await fs.writeFile(path.join(projectPath, file.path), file.content);
    }
    
    // Generate repositories
    const repositoryFiles = this.generateRepositoryFiles();
    for (const file of repositoryFiles) {
      await fs.writeFile(path.join(projectPath, file.path), file.content);
    }
    
    // Generate security configuration
    const securityFiles = this.generateSecurityFiles();
    for (const file of securityFiles) {
      await fs.writeFile(path.join(projectPath, file.path), file.content);
    }
    
    // Generate exception handling
    const exceptionFiles = this.generateExceptionFiles();
    for (const file of exceptionFiles) {
      await fs.writeFile(path.join(projectPath, file.path), file.content);
    }
    
    // Generate database migrations
    const migrationFiles = this.generateMigrationFiles();
    for (const file of migrationFiles) {
      await fs.writeFile(path.join(projectPath, file.path), file.content);
    }
    
    // Generate test files
    const testFiles = this.generateTestFiles();
    for (const file of testFiles) {
      await fs.writeFile(path.join(projectPath, file.path), file.content);
    }
    
    // Generate JWT keys for development
    await this.generateJWTKeys(projectPath);
  }
  
  private generateApplicationLifecycle(): string {
    const packageName = this.getPackageName();
    
    return `package ${packageName};

import io.quarkus.runtime.StartupEvent;
import io.quarkus.runtime.ShutdownEvent;
import org.jboss.logging.Logger;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.event.Observes;

@ApplicationScoped
public class ApplicationLifecycle {
    
    private static final Logger LOGGER = Logger.getLogger("ApplicationLifecycle");
    
    void onStart(@Observes StartupEvent ev) {
        LOGGER.info("ðŸš€ ${this.options?.name || 'Backend API'} is starting with Quarkus");
    }
    
    void onStop(@Observes ShutdownEvent ev) {
        LOGGER.info("ðŸ‘‹ ${this.options?.name || 'Backend API'} is stopping");
    }
}`;
  }
  
  private generateResourceFiles(): { path: string; content: string }[] {
    const packageName = this.getPackageName();
    const packagePath = this.getPackagePath();
    
    return [
      {
        path: `src/main/java/${packagePath}/api/resource/AuthResource.java`,
        content: `package ${packageName}.api.resource;

import ${packageName}.dto.LoginRequestDto;
import ${packageName}.dto.TokenResponseDto;
import ${packageName}.dto.UserRegistrationDto;
import ${packageName}.service.AuthService;
import org.eclipse.microprofile.openapi.annotations.Operation;
import org.eclipse.microprofile.openapi.annotations.media.Content;
import org.eclipse.microprofile.openapi.annotations.media.Schema;
import org.eclipse.microprofile.openapi.annotations.responses.APIResponse;
import org.eclipse.microprofile.openapi.annotations.responses.APIResponses;
import org.eclipse.microprofile.openapi.annotations.tags.Tag;

import jakarta.inject.Inject;
import jakarta.validation.Valid;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;

@Path("/api/v1/auth")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
@Tag(name = "Authentication", description = "Authentication management APIs")
public class AuthResource {
    
    @Inject
    AuthService authService;
    
    @Operation(summary = "Register a new user")
    @APIResponses(value = {
        @APIResponse(responseCode = "201", description = "User registered successfully",
                    content = @Content(schema = @Schema(implementation = TokenResponseDto.class))),
        @APIResponse(responseCode = "400", description = "Invalid input"),
        @APIResponse(responseCode = "409", description = "User already exists")
    })
    @POST
    @Path("/register")
    public Response register(@Valid UserRegistrationDto registrationDto) {
        TokenResponseDto response = authService.register(registrationDto);
        return Response.status(Response.Status.CREATED).entity(response).build();
    }
    
    @Operation(summary = "Login user")
    @APIResponses(value = {
        @APIResponse(responseCode = "200", description = "Login successful",
                    content = @Content(schema = @Schema(implementation = TokenResponseDto.class))),
        @APIResponse(responseCode = "401", description = "Invalid credentials")
    })
    @POST
    @Path("/login")
    public Response login(@Valid LoginRequestDto loginRequest) {
        TokenResponseDto response = authService.login(loginRequest);
        return Response.ok(response).build();
    }
    
    @Operation(summary = "Refresh access token")
    @APIResponses(value = {
        @APIResponse(responseCode = "200", description = "Token refreshed successfully",
                    content = @Content(schema = @Schema(implementation = TokenResponseDto.class))),
        @APIResponse(responseCode = "401", description = "Invalid refresh token")
    })
    @POST
    @Path("/refresh")
    public Response refresh(String refreshToken) {
        TokenResponseDto response = authService.refreshToken(refreshToken);
        return Response.ok(response).build();
    }
    
    @Operation(summary = "Logout user")
    @APIResponses(value = {
        @APIResponse(responseCode = "200", description = "Logout successful")
    })
    @POST
    @Path("/logout")
    public Response logout(String refreshToken) {
        authService.logout(refreshToken);
        return Response.ok().build();
    }
}`
      },
      {
        path: `src/main/java/${packagePath}/api/resource/UserResource.java`,
        content: `package ${packageName}.api.resource;

import ${packageName}.dto.ChangePasswordRequestDto;
import ${packageName}.dto.UserResponseDto;
import ${packageName}.dto.UserUpdateDto;
import ${packageName}.security.JwtPrincipal;
import ${packageName}.service.UserService;
import org.eclipse.microprofile.openapi.annotations.Operation;
import org.eclipse.microprofile.openapi.annotations.Parameter;
import org.eclipse.microprofile.openapi.annotations.media.Content;
import org.eclipse.microprofile.openapi.annotations.media.Schema;
import org.eclipse.microprofile.openapi.annotations.responses.APIResponse;
import org.eclipse.microprofile.openapi.annotations.responses.APIResponses;
import org.eclipse.microprofile.openapi.annotations.security.SecurityRequirement;
import org.eclipse.microprofile.openapi.annotations.tags.Tag;

import jakarta.annotation.security.RolesAllowed;
import jakarta.inject.Inject;
import jakarta.validation.Valid;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.Context;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.SecurityContext;
import java.util.UUID;

@Path("/api/v1/users")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
@Tag(name = "Users", description = "User management APIs")
@SecurityRequirement(name = "bearerAuth")
public class UserResource {
    
    @Inject
    UserService userService;
    
    @Operation(summary = "Get current user profile")
    @APIResponses(value = {
        @APIResponse(responseCode = "200", description = "Profile retrieved successfully",
                    content = @Content(schema = @Schema(implementation = UserResponseDto.class))),
        @APIResponse(responseCode = "401", description = "Unauthorized"),
        @APIResponse(responseCode = "404", description = "User not found")
    })
    @GET
    @Path("/profile")
    @RolesAllowed({"USER", "ADMIN"})
    public Response getProfile(@Context SecurityContext securityContext) {
        JwtPrincipal principal = (JwtPrincipal) securityContext.getUserPrincipal();
        UserResponseDto user = userService.getUserByEmail(principal.getName());
        return Response.ok(user).build();
    }
    
    @Operation(summary = "Update current user profile")
    @APIResponses(value = {
        @APIResponse(responseCode = "200", description = "Profile updated successfully",
                    content = @Content(schema = @Schema(implementation = UserResponseDto.class))),
        @APIResponse(responseCode = "400", description = "Invalid input"),
        @APIResponse(responseCode = "401", description = "Unauthorized"),
        @APIResponse(responseCode = "404", description = "User not found")
    })
    @PUT
    @Path("/profile")
    @RolesAllowed({"USER", "ADMIN"})
    public Response updateProfile(@Context SecurityContext securityContext, @Valid UserUpdateDto updateDto) {
        JwtPrincipal principal = (JwtPrincipal) securityContext.getUserPrincipal();
        UserResponseDto currentUser = userService.getUserByEmail(principal.getName());
        UserResponseDto updatedUser = userService.updateUser(currentUser.getId(), updateDto);
        return Response.ok(updatedUser).build();
    }
    
    @Operation(summary = "Change user password")
    @APIResponses(value = {
        @APIResponse(responseCode = "200", description = "Password changed successfully"),
        @APIResponse(responseCode = "400", description = "Invalid old password"),
        @APIResponse(responseCode = "401", description = "Unauthorized")
    })
    @POST
    @Path("/change-password")
    @RolesAllowed({"USER", "ADMIN"})
    public Response changePassword(@Context SecurityContext securityContext, @Valid ChangePasswordRequestDto changePasswordRequest) {
        JwtPrincipal principal = (JwtPrincipal) securityContext.getUserPrincipal();
        UserResponseDto currentUser = userService.getUserByEmail(principal.getName());
        userService.changePassword(currentUser.getId(), 
                                 changePasswordRequest.getOldPassword(), 
                                 changePasswordRequest.getNewPassword());
        return Response.ok().build();
    }
    
    @Operation(summary = "Delete current user account")
    @APIResponses(value = {
        @APIResponse(responseCode = "200", description = "Account deleted successfully"),
        @APIResponse(responseCode = "401", description = "Unauthorized")
    })
    @DELETE
    @Path("/profile")
    @RolesAllowed({"USER", "ADMIN"})
    public Response deleteAccount(@Context SecurityContext securityContext) {
        JwtPrincipal principal = (JwtPrincipal) securityContext.getUserPrincipal();
        UserResponseDto currentUser = userService.getUserByEmail(principal.getName());
        userService.deleteUser(currentUser.getId());
        return Response.ok().build();
    }
}`
      },
      {
        path: `src/main/java/${packagePath}/api/resource/AdminResource.java`,
        content: `package ${packageName}.api.resource;

import ${packageName}.dto.UserResponseDto;
import ${packageName}.dto.UserUpdateDto;
import ${packageName}.service.UserService;
import org.eclipse.microprofile.openapi.annotations.Operation;
import org.eclipse.microprofile.openapi.annotations.Parameter;
import org.eclipse.microprofile.openapi.annotations.media.Content;
import org.eclipse.microprofile.openapi.annotations.media.Schema;
import org.eclipse.microprofile.openapi.annotations.responses.APIResponse;
import org.eclipse.microprofile.openapi.annotations.responses.APIResponses;
import org.eclipse.microprofile.openapi.annotations.security.SecurityRequirement;
import org.eclipse.microprofile.openapi.annotations.tags.Tag;

import jakarta.annotation.security.RolesAllowed;
import jakarta.inject.Inject;
import jakarta.validation.Valid;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import java.util.UUID;

@Path("/api/v1/admin")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
@Tag(name = "Admin", description = "Admin management APIs")
@SecurityRequirement(name = "bearerAuth")
@RolesAllowed("ADMIN")
public class AdminResource {
    
    @Inject
    UserService userService;
    
    @Operation(summary = "Get all users with pagination")
    @APIResponses(value = {
        @APIResponse(responseCode = "200", description = "Users retrieved successfully"),
        @APIResponse(responseCode = "401", description = "Unauthorized"),
        @APIResponse(responseCode = "403", description = "Forbidden")
    })
    @GET
    @Path("/users")
    public Response getAllUsers(@QueryParam("page") @DefaultValue("0") int page,
                               @QueryParam("size") @DefaultValue("10") int size) {
        var users = userService.getAllUsers(page, size);
        return Response.ok(users).build();
    }
    
    @Operation(summary = "Get user by ID")
    @APIResponses(value = {
        @APIResponse(responseCode = "200", description = "User retrieved successfully",
                    content = @Content(schema = @Schema(implementation = UserResponseDto.class))),
        @APIResponse(responseCode = "401", description = "Unauthorized"),
        @APIResponse(responseCode = "403", description = "Forbidden"),
        @APIResponse(responseCode = "404", description = "User not found")
    })
    @GET
    @Path("/users/{id}")
    public Response getUserById(@Parameter(description = "User ID") @PathParam("id") UUID id) {
        UserResponseDto user = userService.getUserById(id);
        return Response.ok(user).build();
    }
    
    @Operation(summary = "Update user by ID")
    @APIResponses(value = {
        @APIResponse(responseCode = "200", description = "User updated successfully",
                    content = @Content(schema = @Schema(implementation = UserResponseDto.class))),
        @APIResponse(responseCode = "400", description = "Invalid input"),
        @APIResponse(responseCode = "401", description = "Unauthorized"),
        @APIResponse(responseCode = "403", description = "Forbidden"),
        @APIResponse(responseCode = "404", description = "User not found")
    })
    @PUT
    @Path("/users/{id}")
    public Response updateUser(@Parameter(description = "User ID") @PathParam("id") UUID id,
                              @Valid UserUpdateDto updateDto) {
        UserResponseDto updatedUser = userService.updateUser(id, updateDto);
        return Response.ok(updatedUser).build();
    }
    
    @Operation(summary = "Delete user by ID")
    @APIResponses(value = {
        @APIResponse(responseCode = "200", description = "User deleted successfully"),
        @APIResponse(responseCode = "401", description = "Unauthorized"),
        @APIResponse(responseCode = "403", description = "Forbidden"),
        @APIResponse(responseCode = "404", description = "User not found")
    })
    @DELETE
    @Path("/users/{id}")
    public Response deleteUser(@Parameter(description = "User ID") @PathParam("id") UUID id) {
        userService.deleteUser(id);
        return Response.ok().build();
    }
}`
      },
      {
        path: `src/main/java/${packagePath}/api/resource/HealthResource.java`,
        content: `package ${packageName}.api.resource;

import io.agroal.api.AgroalDataSource;
import org.eclipse.microprofile.openapi.annotations.Operation;
import org.eclipse.microprofile.openapi.annotations.responses.APIResponse;
import org.eclipse.microprofile.openapi.annotations.responses.APIResponses;
import org.eclipse.microprofile.openapi.annotations.tags.Tag;

import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import java.sql.Connection;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@Path("/api/v1")
@Produces(MediaType.APPLICATION_JSON)
@Tag(name = "Health", description = "Health check APIs")
public class HealthResource {
    
    @Inject
    AgroalDataSource dataSource;
    
    @Operation(summary = "Health check endpoint")
    @APIResponses(value = {
        @APIResponse(responseCode = "200", description = "Service is healthy"),
        @APIResponse(responseCode = "503", description = "Service is unhealthy")
    })
    @GET
    @Path("/health")
    public Response health() {
        Map<String, Object> response = new HashMap<>();
        
        try {
            // Check database connection
            try (Connection connection = dataSource.getConnection()) {
                connection.isValid(1);
                response.put("database", "healthy");
            } catch (Exception e) {
                response.put("database", "unhealthy");
                response.put("status", "degraded");
            }
            
            // Add basic service info
            response.put("service", "${this.options?.name || 'Backend API'}");
            response.put("framework", "Quarkus");
            response.put("timestamp", LocalDateTime.now());
            response.put("uptime", System.currentTimeMillis());
            
            if (!response.containsKey("status")) {
                response.put("status", "healthy");
            }
            
            return Response.ok(response).build();
            
        } catch (Exception e) {
            response.put("status", "unhealthy");
            response.put("error", e.getMessage());
            return Response.status(503).entity(response).build();
        }
    }
}`
      }
    ];
  }
  
  private generateRepositoryFiles(): { path: string; content: string }[] {
    const packageName = this.getPackageName();
    const packagePath = this.getPackagePath();
    
    return [
      {
        path: `src/main/java/${packagePath}/repository/UserRepository.java`,
        content: `package ${packageName}.repository;

import ${packageName}.model.User;
import io.quarkus.hibernate.orm.panache.PanacheRepository;
import io.quarkus.panache.common.Page;
import io.quarkus.panache.common.Sort;

import jakarta.enterprise.context.ApplicationScoped;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@ApplicationScoped
public class UserRepository implements PanacheRepository<User> {
    
    public Optional<User> findByEmail(String email) {
        return find("email", email).firstResultOptional();
    }
    
    public boolean existsByEmail(String email) {
        return count("email", email) > 0;
    }
    
    public List<User> findAllActiveUsers(int page, int size) {
        return find("active = true", Sort.by("createdAt").descending())
                .page(Page.of(page, size))
                .list();
    }
    
    public List<User> findByRole(User.UserRole role, int page, int size) {
        return find("role", role)
                .page(Page.of(page, size))
                .list();
    }
    
    public long countActiveUsers() {
        return count("active = true");
    }
    
    public List<User> findBySearchTerm(String search, int page, int size) {
        if (search == null || search.trim().isEmpty()) {
            return findAll(Sort.by("createdAt").descending())
                    .page(Page.of(page, size))
                    .list();
        }
        
        String searchPattern = "%" + search.toLowerCase() + "%";
        return find("LOWER(firstName) LIKE ?1 OR LOWER(lastName) LIKE ?1 OR LOWER(email) LIKE ?1", 
                   searchPattern)
                .page(Page.of(page, size))
                .list();
    }
}`
      },
      {
        path: `src/main/java/${packagePath}/repository/RefreshTokenRepository.java`,
        content: `package ${packageName}.repository;

import ${packageName}.model.RefreshToken;
import io.quarkus.hibernate.orm.panache.PanacheRepository;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.transaction.Transactional;
import java.time.LocalDateTime;
import java.util.Optional;
import java.util.UUID;

@ApplicationScoped
public class RefreshTokenRepository implements PanacheRepository<RefreshToken> {
    
    public Optional<RefreshToken> findByToken(String token) {
        return find("token", token).firstResultOptional();
    }
    
    @Transactional
    public void deleteByUserId(UUID userId) {
        delete("user.id", userId);
    }
    
    @Transactional
    public void deleteExpiredTokens(LocalDateTime now) {
        delete("expiryDate < ?1", now);
    }
    
    public long countByUserId(UUID userId) {
        return count("user.id", userId);
    }
}`
      }
    ];
  }
  
  private generateSecurityFiles(): { path: string; content: string }[] {
    const packageName = this.getPackageName();
    const packagePath = this.getPackagePath();
    
    return [
      {
        path: `src/main/java/${packagePath}/security/JwtPrincipal.java`,
        content: `package ${packageName}.security;

import java.security.Principal;
import java.util.Set;
import java.util.UUID;

public class JwtPrincipal implements Principal {
    private final String email;
    private final UUID userId;
    private final Set<String> roles;
    
    public JwtPrincipal(String email, UUID userId, Set<String> roles) {
        this.email = email;
        this.userId = userId;
        this.roles = roles;
    }
    
    @Override
    public String getName() {
        return email;
    }
    
    public UUID getUserId() {
        return userId;
    }
    
    public Set<String> getRoles() {
        return roles;
    }
    
    public boolean hasRole(String role) {
        return roles.contains(role);
    }
}`
      },
      {
        path: `src/main/java/${packagePath}/security/JwtTokenProvider.java`,
        content: `package ${packageName}.security;

import io.smallrye.jwt.build.Jwt;
import io.smallrye.jwt.build.JwtClaimsBuilder;
import org.eclipse.microprofile.config.inject.ConfigProperty;

import jakarta.enterprise.context.ApplicationScoped;
import java.time.Duration;
import java.time.Instant;
import java.util.Set;
import java.util.UUID;

@ApplicationScoped
public class JwtTokenProvider {
    
    @ConfigProperty(name = "mp.jwt.verify.issuer")
    String issuer;
    
    public String generateAccessToken(String email, UUID userId, Set<String> roles) {
        return Jwt.issuer(issuer)
                .subject(email)
                .claim("userId", userId.toString())
                .claim("email", email)
                .groups(roles)
                .issuedAt(Instant.now())
                .expiresAt(Instant.now().plus(Duration.ofHours(24)))
                .sign();
    }
    
    public String generateRefreshToken() {
        return UUID.randomUUID().toString();
    }
}`
      }
    ];
  }
  
  private generateExceptionFiles(): { path: string; content: string }[] {
    const packageName = this.getPackageName();
    const packagePath = this.getPackagePath();
    
    return [
      {
        path: `src/main/java/${packagePath}/exception/GlobalExceptionMapper.java`,
        content: `package ${packageName}.exception;

import org.jboss.logging.Logger;

import jakarta.validation.ConstraintViolationException;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.ext.ExceptionMapper;
import jakarta.ws.rs.ext.Provider;
import java.time.LocalDateTime;

@Provider
public class GlobalExceptionMapper implements ExceptionMapper<Throwable> {
    
    private static final Logger LOGGER = Logger.getLogger(GlobalExceptionMapper.class);
    
    @Override
    public Response toResponse(Throwable exception) {
        LOGGER.error("Exception occurred", exception);
        
        if (exception instanceof ResourceNotFoundException) {
            return createErrorResponse(Response.Status.NOT_FOUND, "Not Found", exception.getMessage());
        }
        
        if (exception instanceof UserAlreadyExistsException) {
            return createErrorResponse(Response.Status.CONFLICT, "Conflict", exception.getMessage());
        }
        
        if (exception instanceof InvalidCredentialsException) {
            return createErrorResponse(Response.Status.UNAUTHORIZED, "Unauthorized", exception.getMessage());
        }
        
        if (exception instanceof ConstraintViolationException) {
            return createErrorResponse(Response.Status.BAD_REQUEST, "Validation Failed", 
                                     "Input validation failed: " + exception.getMessage());
        }
        
        if (exception instanceof IllegalArgumentException) {
            return createErrorResponse(Response.Status.BAD_REQUEST, "Bad Request", exception.getMessage());
        }
        
        // Default to internal server error
        return createErrorResponse(Response.Status.INTERNAL_SERVER_ERROR, "Internal Server Error", 
                                 "An unexpected error occurred");
    }
    
    private Response createErrorResponse(Response.Status status, String error, String message) {
        ErrorResponse errorResponse = new ErrorResponse(
            LocalDateTime.now(),
            status.getStatusCode(),
            error,
            message,
            ""
        );
        return Response.status(status).entity(errorResponse).build();
    }
}`
      },
      {
        path: `src/main/java/${packagePath}/exception/ErrorResponse.java`,
        content: `package ${packageName}.exception;

import java.time.LocalDateTime;

public class ErrorResponse {
    private LocalDateTime timestamp;
    private int status;
    private String error;
    private String message;
    private String path;
    
    public ErrorResponse() {}
    
    public ErrorResponse(LocalDateTime timestamp, int status, String error, String message, String path) {
        this.timestamp = timestamp;
        this.status = status;
        this.error = error;
        this.message = message;
        this.path = path;
    }
    
    // Getters and Setters
    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
    
    public int getStatus() { return status; }
    public void setStatus(int status) { this.status = status; }
    
    public String getError() { return error; }
    public void setError(String error) { this.error = error; }
    
    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
    
    public String getPath() { return path; }
    public void setPath(String path) { this.path = path; }
}`
      },
      {
        path: `src/main/java/${packagePath}/exception/ResourceNotFoundException.java`,
        content: `package ${packageName}.exception;

public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
    
    public ResourceNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}`
      },
      {
        path: `src/main/java/${packagePath}/exception/UserAlreadyExistsException.java`,
        content: `package ${packageName}.exception;

public class UserAlreadyExistsException extends RuntimeException {
    public UserAlreadyExistsException(String message) {
        super(message);
    }
    
    public UserAlreadyExistsException(String message, Throwable cause) {
        super(message, cause);
    }
}`
      },
      {
        path: `src/main/java/${packagePath}/exception/InvalidCredentialsException.java`,
        content: `package ${packageName}.exception;

public class InvalidCredentialsException extends RuntimeException {
    public InvalidCredentialsException(String message) {
        super(message);
    }
    
    public InvalidCredentialsException(String message, Throwable cause) {
        super(message, cause);
    }
}`
      }
    ];
  }
  
  private generateMigrationFiles(): { path: string; content: string }[] {
    return [
      {
        path: 'src/main/resources/db/migration/V1__Create_users_table.sql',
        content: `-- Create users table
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    role VARCHAR(20) NOT NULL DEFAULT 'USER',
    active BOOLEAN NOT NULL DEFAULT true,
    email_verified BOOLEAN NOT NULL DEFAULT false,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role);
CREATE INDEX idx_users_active ON users(active);
CREATE INDEX idx_users_created_at ON users(created_at);

-- Create updated_at trigger
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();`
      },
      {
        path: 'src/main/resources/db/migration/V2__Create_refresh_tokens_table.sql',
        content: `-- Create refresh_tokens table
CREATE TABLE refresh_tokens (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    token VARCHAR(255) NOT NULL UNIQUE,
    user_id UUID NOT NULL,
    expiry_date TIMESTAMP NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Create indexes
CREATE INDEX idx_refresh_tokens_token ON refresh_tokens(token);
CREATE INDEX idx_refresh_tokens_user_id ON refresh_tokens(user_id);
CREATE INDEX idx_refresh_tokens_expiry_date ON refresh_tokens(expiry_date);`
      }
    ];
  }
  
  private generateTestFiles(): { path: string; content: string }[] {
    const packageName = this.getPackageName();
    const packagePath = this.getPackagePath();
    
    return [
      {
        path: `src/test/java/${packagePath}/ApplicationTest.java`,
        content: `package ${packageName};

import io.quarkus.test.junit.QuarkusTest;
import org.junit.jupiter.api.Test;

import static io.restassured.RestAssured.given;
import static org.hamcrest.CoreMatchers.is;

@QuarkusTest
public class ApplicationTest {

    @Test
    public void testHealthEndpoint() {
        given()
          .when().get("/api/v1/health")
          .then()
             .statusCode(200)
             .body("status", is("healthy"));
    }
}`
      },
      {
        path: 'src/test/resources/application.properties',
        content: `# Test Configuration
quarkus.application.name=${this.options?.name || 'backend-api'}-test

# In-memory H2 database for tests
quarkus.datasource.db-kind=h2
quarkus.datasource.username=sa
quarkus.datasource.password=
quarkus.datasource.jdbc.url=jdbc:h2:mem:testdb

# Hibernate ORM Configuration for tests
quarkus.hibernate-orm.database.generation=drop-and-create
quarkus.hibernate-orm.log.sql=true

# Disable Flyway for tests
quarkus.flyway.migrate-at-start=false

# Redis Configuration for tests (embedded)
quarkus.redis.hosts=redis://localhost:6370

# JWT Configuration for tests
mp.jwt.verify.publickey.location=META-INF/publicKey.pem
mp.jwt.verify.issuer=https://test.example.com
smallrye.jwt.sign.key.location=META-INF/privateKey.pem

# Health Check Configuration for tests
quarkus.health.extensions.enabled=true

# Logging Configuration for tests
quarkus.log.console.level=INFO`
      }
    ];
  }
  
  private async generateJWTKeys(projectPath: string): Promise<void> {
    // Create META-INF directory
    await fs.mkdir(path.join(projectPath, 'src/main/resources/META-INF'), { recursive: true });
    await fs.mkdir(path.join(projectPath, 'src/test/resources/META-INF'), { recursive: true });
    
    // Generate dummy keys for development (in production, use proper key generation)
    const privateKey = `-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQC7VJTUt9Us8cKB
xWPMB+m1+rTIGOXdqQKX9Y6kNrX9Z1Zm1Pb4i+8JHPfEqkOYgKh4sLjhp1R7j1s
-----END PRIVATE KEY-----`;

    const publicKey = `-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAu1SU1L7VLPHCgcVjzAfp
tfq0yBjl3akCl/WOpDa1/WdWZtT2+IvvCRz3xKpDmICoeLC44adUe49bOQKBgQC
-----END PUBLIC KEY-----`;
    
    // Write keys for main and test
    await fs.writeFile(path.join(projectPath, 'src/main/resources/META-INF/privateKey.pem'), privateKey);
    await fs.writeFile(path.join(projectPath, 'src/main/resources/META-INF/publicKey.pem'), publicKey);
    await fs.writeFile(path.join(projectPath, 'src/test/resources/META-INF/privateKey.pem'), privateKey);
    await fs.writeFile(path.join(projectPath, 'src/test/resources/META-INF/publicKey.pem'), publicKey);
  }
}