import { JavaBackendGenerator } from './java-base-generator';
import { promises as fs } from 'fs';
import * as path from 'path';

export class MicronautGenerator extends JavaBackendGenerator {
  constructor() {
    super('Micronaut');
  }

  protected async createJavaDirectoryStructure(projectPath: string): Promise<void> {
    const packagePath = this.getPackagePath();
    
    const directories = [
      'src/main/java',
      `src/main/java/${packagePath}`,
      `src/main/java/${packagePath}/controller`,
      `src/main/java/${packagePath}/service`,
      `src/main/java/${packagePath}/repository`,
      `src/main/java/${packagePath}/domain`,
      `src/main/java/${packagePath}/model`,
      `src/main/java/${packagePath}/dto`,
      `src/main/java/${packagePath}/config`,
      `src/main/java/${packagePath}/security`,
      `src/main/java/${packagePath}/client`,
      `src/main/java/${packagePath}/exception`,
      `src/main/java/${packagePath}/util`,
      'src/main/resources',
      'src/main/resources/db',
      'src/main/resources/db/migration',
      'src/test/java',
      `src/test/java/${packagePath}`,
      `src/test/java/${packagePath}/controller`,
      `src/test/java/${packagePath}/service`,
      `src/test/java/${packagePath}/repository`,
      `src/test/java/${packagePath}/integration`,
      'src/test/resources',
      'target',
      '.mvn',
      '.mvn/wrapper'
    ];

    for (const dir of directories) {
      await fs.mkdir(path.join(projectPath, dir), { recursive: true });
    }
  }

  protected async generateFrameworkFiles(projectPath: string, options: any): Promise<void> {
    this.options = options;
    
    // Ensure Micronaut-specific directory structure exists
    await this.createJavaDirectoryStructure(projectPath);
    
    // Call parent implementation
    await super.generateFrameworkFiles(projectPath, options);
  }

  protected getPackageName(): string {
    return `com.${this.sanitizeName(this.options?.name || 'example')}`;
  }

  protected getFrameworkDependencies(): Record<string, string> {
    return {
      'io.micronaut:micronaut-http-server-netty': '',
      'io.micronaut:micronaut-validation': '',
      'io.micronaut:micronaut-jackson-databind': '',
      'io.micronaut.security:micronaut-security-jwt': '',
      'io.micronaut.data:micronaut-data-hibernate-jpa': '',
      'io.micronaut.flyway:micronaut-flyway': '',
      'io.micronaut.redis:micronaut-redis-lettuce': '',
      'io.micronaut:micronaut-management': '',
      'io.micronaut.micrometer:micronaut-micrometer-core': '',
      'io.micronaut.micrometer:micronaut-micrometer-registry-prometheus': '',
      'io.micronaut.openapi:micronaut-openapi': '',
      'io.micronaut.tracing:micronaut-tracing-jaeger': '',
      'io.micronaut:micronaut-websocket': '',
      'io.micronaut.email:micronaut-email-javamail': '',
      'jakarta.persistence:jakarta.persistence-api': '',
      'org.postgresql:postgresql': 'runtime',
      'io.micronaut:micronaut-http-client': 'test',
      'io.micronaut.test:micronaut-test-junit5': 'test',
      'com.h2database:h2': 'test'
    };
  }
  
  protected generatePomXml(): string {
    const groupId = `com.${this.sanitizeName(this.options?.name || 'example')}`;
    const artifactId = this.sanitizeName(this.options?.name || 'api');
    const frameworkDeps = this.getFrameworkDependencies();
    
    return `<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <groupId>${groupId}</groupId>
    <artifactId>${artifactId}</artifactId>
    <version>1.0.0</version>
    <name>${this.options?.name || 'Backend API'}</name>
    <description>Micronaut backend service generated by Re-Shell</description>
    
    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <micronaut.version>4.2.3</micronaut.version>
        <micronaut.data.version>4.8.2</micronaut.data.version>
        <micronaut.security.version>4.5.0</micronaut.security.version>
        <micronaut.test.version>4.1.1</micronaut.test.version>
        <junit.version>5.10.1</junit.version>
        <logback.version>1.4.14</logback.version>
        <exec.mainClass>\${exec.mainClass}</exec.mainClass>
    </properties>
    
    <repositories>
        <repository>
            <id>central</id>
            <url>https://repo1.maven.org/maven2</url>
        </repository>
    </repositories>
    
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>io.micronaut.platform</groupId>
                <artifactId>micronaut-platform</artifactId>
                <version>\${micronaut.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    
    <dependencies>
        <!-- Micronaut Core -->
        <dependency>
            <groupId>io.micronaut</groupId>
            <artifactId>micronaut-inject</artifactId>
        </dependency>
        <dependency>
            <groupId>io.micronaut</groupId>
            <artifactId>micronaut-http-server-netty</artifactId>
        </dependency>
        <dependency>
            <groupId>io.micronaut</groupId>
            <artifactId>micronaut-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>io.micronaut</groupId>
            <artifactId>micronaut-jackson-databind</artifactId>
        </dependency>
        
        <!-- Security -->
        <dependency>
            <groupId>io.micronaut.security</groupId>
            <artifactId>micronaut-security-jwt</artifactId>
        </dependency>
        
        <!-- Data -->
        <dependency>
            <groupId>io.micronaut.data</groupId>
            <artifactId>micronaut-data-hibernate-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>io.micronaut.flyway</groupId>
            <artifactId>micronaut-flyway</artifactId>
        </dependency>
        <dependency>
            <groupId>jakarta.persistence</groupId>
            <artifactId>jakarta.persistence-api</artifactId>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <!-- Redis -->
        <dependency>
            <groupId>io.micronaut.redis</groupId>
            <artifactId>micronaut-redis-lettuce</artifactId>
        </dependency>
        
        <!-- Management & Monitoring -->
        <dependency>
            <groupId>io.micronaut</groupId>
            <artifactId>micronaut-management</artifactId>
        </dependency>
        <dependency>
            <groupId>io.micronaut.micrometer</groupId>
            <artifactId>micronaut-micrometer-core</artifactId>
        </dependency>
        <dependency>
            <groupId>io.micronaut.micrometer</groupId>
            <artifactId>micronaut-micrometer-registry-prometheus</artifactId>
        </dependency>
        
        <!-- Documentation -->
        <dependency>
            <groupId>io.micronaut.openapi</groupId>
            <artifactId>micronaut-openapi</artifactId>
        </dependency>
        
        <!-- Tracing -->
        <dependency>
            <groupId>io.micronaut.tracing</groupId>
            <artifactId>micronaut-tracing-jaeger</artifactId>
        </dependency>
        
        <!-- WebSocket -->
        <dependency>
            <groupId>io.micronaut</groupId>
            <artifactId>micronaut-websocket</artifactId>
        </dependency>
        
        <!-- Email -->
        <dependency>
            <groupId>io.micronaut.email</groupId>
            <artifactId>micronaut-email-javamail</artifactId>
        </dependency>
        
        <!-- Logging -->
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>\${logback.version}</version>
            <scope>runtime</scope>
        </dependency>
        
        <!-- Test Dependencies -->
        <dependency>
            <groupId>io.micronaut</groupId>
            <artifactId>micronaut-http-client</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.micronaut.test</groupId>
            <artifactId>micronaut-test-junit5</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-api</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>io.micronaut.maven</groupId>
                <artifactId>micronaut-maven-plugin</artifactId>
                <version>4.2.1</version>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <release>17</release>
                    <annotationProcessorPaths combine.children="append">
                        <path>
                            <groupId>io.micronaut</groupId>
                            <artifactId>micronaut-inject-java</artifactId>
                            <version>\${micronaut.version}</version>
                        </path>
                        <path>
                            <groupId>io.micronaut.data</groupId>
                            <artifactId>micronaut-data-processor</artifactId>
                            <version>\${micronaut.data.version}</version>
                        </path>
                        <path>
                            <groupId>io.micronaut</groupId>
                            <artifactId>micronaut-validation</artifactId>
                            <version>\${micronaut.version}</version>
                        </path>
                        <path>
                            <groupId>io.micronaut.security</groupId>
                            <artifactId>micronaut-security-annotations</artifactId>
                            <version>\${micronaut.security.version}</version>
                        </path>
                        <path>
                            <groupId>io.micronaut.openapi</groupId>
                            <artifactId>micronaut-openapi</artifactId>
                            <version>5.2.0</version>
                        </path>
                    </annotationProcessorPaths>
                    <compilerArgs>
                        <arg>-Amicronaut.processing.group=\${project.groupId}</arg>
                        <arg>-Amicronaut.processing.module=\${project.artifactId}</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.2.2</version>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-failsafe-plugin</artifactId>
                <version>3.2.2</version>
            </plugin>
        </plugins>
    </build>
    
    <profiles>
        <profile>
            <id>native</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.graalvm.buildtools</groupId>
                        <artifactId>native-maven-plugin</artifactId>
                        <version>0.9.28</version>
                        <extensions>true</extensions>
                        <executions>
                            <execution>
                                <id>build-native</id>
                                <goals>
                                    <goal>compile-no-fork</goal>
                                </goals>
                                <phase>package</phase>
                            </execution>
                        </executions>
                        <configuration>
                            <fallback>false</fallback>
                            <buildArgs>
                                <buildArg>--verbose</buildArg>
                            </buildArgs>
                        </configuration>
                    </plugin>
                </plugins>
            </build>
        </profile>
    </profiles>
</project>`;
  }

  protected generateApplicationProperties(): string {
    const dbName = this.sanitizeName(this.options?.name || 'example') + '_db';
    
    return `# Micronaut Application Configuration
micronaut.application.name=${this.options?.name || 'backend-api'}
micronaut.server.port=${this.options?.port || 8080}

# Database Configuration
datasources.default.url=jdbc:postgresql://localhost:5432/${dbName}
datasources.default.username=postgres
datasources.default.password=password
datasources.default.driver-class-name=org.postgresql.Driver
datasources.default.dialect=POSTGRES

# JPA Configuration
jpa.default.properties.hibernate.hbm2ddl.auto=validate
jpa.default.properties.hibernate.show_sql=false
jpa.default.properties.hibernate.format_sql=true

# Security Configuration
micronaut.security.authentication=bearer
micronaut.security.token.jwt.signatures.secret.generator.secret=\${JWT_SECRET:pleaseChangeThisSecretForProduction}
micronaut.security.token.jwt.generator.access-token.expiration=3600

# Redis Configuration
redis.uri=redis://localhost:6379

# Management & Health
endpoints.all.enabled=true
endpoints.health.enabled=true
endpoints.info.enabled=true
endpoints.metrics.enabled=true
endpoints.prometheus.enabled=true

# Tracing Configuration
tracing.jaeger.enabled=true
tracing.jaeger.sampler.type=const
tracing.jaeger.sampler.param=1
tracing.jaeger.reporter.log-spans=true

# Logging Configuration
logger.levels.com.${this.sanitizeName(this.options?.name || 'example')}=DEBUG
logger.levels.io.micronaut.security=DEBUG
logger.levels.io.micronaut.data.query=DEBUG

# Email Configuration
micronaut.email.from.email=noreply@${this.sanitizeName(this.options?.name || 'example')}.com
micronaut.email.from.name=${this.options?.name || 'Backend API'}
`;
  }

  protected generateApplicationYml(): string {
    const dbName = this.sanitizeName(this.options?.name || 'example') + '_db';
    
    return `micronaut:
  application:
    name: ${this.options?.name || 'backend-api'}
  server:
    port: ${this.options?.port || 8080}
  security:
    authentication: bearer
    token:
      jwt:
        signatures:
          secret:
            generator:
              secret: \${JWT_SECRET:pleaseChangeThisSecretForProduction}
        generator:
          access-token:
            expiration: 3600

datasources:
  default:
    url: jdbc:postgresql://localhost:5432/${dbName}
    username: postgres
    password: password
    driver-class-name: org.postgresql.Driver
    dialect: POSTGRES

jpa:
  default:
    properties:
      hibernate:
        hbm2ddl:
          auto: validate
        show_sql: false
        format_sql: true

redis:
  uri: redis://localhost:6379

endpoints:
  all:
    enabled: true
  health:
    enabled: true
  info:
    enabled: true
  metrics:
    enabled: true
  prometheus:
    enabled: true

tracing:
  jaeger:
    enabled: true
    sampler:
      type: const
      param: 1
    reporter:
      log-spans: true

logger:
  levels:
    com.${this.sanitizeName(this.options?.name || 'example')}: DEBUG
    io.micronaut.security: DEBUG
    io.micronaut.data.query: DEBUG
`;
  }

  protected async generateFrameworkSpecificFiles(projectPath: string, options: any): Promise<void> {
    const packageName = this.getPackageName();
    const packagePath = this.getPackagePath();
    
    const files = [
      // Application class
      {
        path: `src/main/java/${packagePath}/Application.java`,
        content: `package ${packageName};

import io.micronaut.runtime.Micronaut;
import io.swagger.v3.oas.annotations.OpenAPIDefinition;
import io.swagger.v3.oas.annotations.info.Info;

@OpenAPIDefinition(
    info = @Info(
        title = "${this.options?.name || 'Backend API'}",
        version = "1.0",
        description = "Micronaut REST API generated by Re-Shell"
    )
)
public class Application {
    public static void main(String[] args) {
        Micronaut.run(Application.class, args);
    }
}`
      },

      // Controllers
      {
        path: `src/main/java/${packagePath}/controller/AuthController.java`,
        content: `package ${packageName}.controller;

import ${packageName}.dto.LoginRequestDto;
import ${packageName}.dto.TokenResponseDto;
import ${packageName}.dto.UserRegistrationDto;
import ${packageName}.service.AuthService;
import io.micronaut.http.HttpResponse;
import io.micronaut.http.annotation.*;
import io.micronaut.security.annotation.Secured;
import io.micronaut.security.rules.SecurityRule;
import io.micronaut.validation.Validated;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import jakarta.inject.Inject;
import jakarta.validation.Valid;

@Controller("/api/v1/auth")
@Validated
@Tag(name = "Authentication", description = "Authentication operations")
@Secured(SecurityRule.IS_ANONYMOUS)
public class AuthController {

    @Inject
    private AuthService authService;

    @Operation(summary = "Register new user")
    @ApiResponse(responseCode = "201", description = "User registered successfully")
    @ApiResponse(responseCode = "400", description = "Invalid input")
    @ApiResponse(responseCode = "409", description = "User already exists")
    @Post("/register")
    public HttpResponse<TokenResponseDto> register(@Valid @Body UserRegistrationDto registrationDto) {
        TokenResponseDto response = authService.register(registrationDto);
        return HttpResponse.created(response);
    }
    
    @Operation(summary = "Login user")
    @ApiResponse(responseCode = "200", description = "Login successful")
    @ApiResponse(responseCode = "401", description = "Invalid credentials")
    @Post("/login")
    public HttpResponse<TokenResponseDto> login(@Valid @Body LoginRequestDto loginDto) {
        TokenResponseDto response = authService.login(loginDto);
        return HttpResponse.ok(response);
    }
    
    @Operation(summary = "Refresh access token")
    @ApiResponse(responseCode = "200", description = "Token refreshed successfully")
    @ApiResponse(responseCode = "401", description = "Invalid refresh token")
    @Post("/refresh")
    public HttpResponse<TokenResponseDto> refresh(@Header("Authorization") String refreshToken) {
        TokenResponseDto response = authService.refreshToken(refreshToken);
        return HttpResponse.ok(response);
    }
}`
      },

      {
        path: `src/main/java/${packagePath}/controller/UserController.java`,
        content: `package ${packageName}.controller;

import ${packageName}.dto.ChangePasswordRequestDto;
import ${packageName}.dto.UserResponseDto;
import ${packageName}.dto.UserUpdateDto;
import ${packageName}.service.UserService;
import io.micronaut.data.model.Page;
import io.micronaut.data.model.Pageable;
import io.micronaut.http.HttpResponse;
import io.micronaut.http.annotation.*;
import io.micronaut.security.annotation.Secured;
import io.micronaut.security.authentication.Authentication;
import io.micronaut.validation.Validated;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import jakarta.inject.Inject;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotNull;
import java.util.UUID;

@Controller("/api/v1/users")
@Validated
@Tag(name = "Users", description = "User management operations")
@Secured("ROLE_USER")
public class UserController {

    @Inject
    private UserService userService;

    @Operation(summary = "Get all users")
    @ApiResponse(responseCode = "200", description = "Users retrieved successfully")
    @Get
    @Secured("ROLE_ADMIN")
    public HttpResponse<Page<UserResponseDto>> getAllUsers(@Parameter(description = "Pagination") Pageable pageable) {
        Page<UserResponseDto> users = userService.getAllUsers(pageable);
        return HttpResponse.ok(users);
    }
    
    @Operation(summary = "Get current user profile")
    @ApiResponse(responseCode = "200", description = "User profile retrieved successfully")
    @Get("/me")
    public HttpResponse<UserResponseDto> getCurrentUser(Authentication authentication) {
        String email = authentication.getName();
        UserResponseDto user = userService.getUserByEmail(email);
        return HttpResponse.ok(user);
    }
    
    @Operation(summary = "Get user by ID")
    @ApiResponse(responseCode = "200", description = "User retrieved successfully")
    @ApiResponse(responseCode = "404", description = "User not found")
    @Get("/{id}")
    @Secured("ROLE_ADMIN")
    public HttpResponse<UserResponseDto> getUserById(@PathVariable UUID id) {
        UserResponseDto user = userService.getUserById(id);
        return HttpResponse.ok(user);
    }
    
    @Operation(summary = "Update user profile")
    @ApiResponse(responseCode = "200", description = "User updated successfully")
    @ApiResponse(responseCode = "404", description = "User not found")
    @Put("/{id}")
    public HttpResponse<UserResponseDto> updateUser(
            @PathVariable UUID id,
            @Valid @Body UserUpdateDto updateDto,
            Authentication authentication) {
        // Users can only update their own profile, admins can update any
        String currentUserEmail = authentication.getName();
        UserResponseDto updatedUser = userService.updateUser(id, updateDto, currentUserEmail);
        return HttpResponse.ok(updatedUser);
    }
    
    @Operation(summary = "Change user password")
    @ApiResponse(responseCode = "200", description = "Password changed successfully")
    @ApiResponse(responseCode = "400", description = "Invalid current password")
    @Put("/{id}/password")
    public HttpResponse<Void> changePassword(
            @PathVariable UUID id,
            @Valid @Body ChangePasswordRequestDto passwordDto,
            Authentication authentication) {
        String currentUserEmail = authentication.getName();
        userService.changePassword(id, passwordDto, currentUserEmail);
        return HttpResponse.ok();
    }
    
    @Operation(summary = "Delete user")
    @ApiResponse(responseCode = "204", description = "User deleted successfully")
    @ApiResponse(responseCode = "404", description = "User not found")
    @Delete("/{id}")
    @Secured("ROLE_ADMIN")
    public HttpResponse<Void> deleteUser(@PathVariable UUID id) {
        userService.deleteUser(id);
        return HttpResponse.noContent();
    }
}`
      },

      {
        path: `src/main/java/${packagePath}/controller/HealthController.java`,
        content: `package ${packageName}.controller;

import io.micronaut.http.HttpResponse;
import io.micronaut.http.annotation.Controller;
import io.micronaut.http.annotation.Get;
import io.micronaut.security.annotation.Secured;
import io.micronaut.security.rules.SecurityRule;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import java.time.LocalDateTime;
import java.util.Map;

@Controller("/api/v1/health")
@Tag(name = "Health", description = "Health check operations")
@Secured(SecurityRule.IS_ANONYMOUS)
public class HealthController {

    @Operation(summary = "Check application health")
    @ApiResponse(responseCode = "200", description = "Application is healthy")
    @Get
    public HttpResponse<Map<String, Object>> health() {
        return HttpResponse.ok(Map.of(
            "status", "UP",
            "timestamp", LocalDateTime.now(),
            "service", "${this.options?.name || 'backend-api'}",
            "version", "1.0.0"
        ));
    }
    
    @Operation(summary = "Check readiness")
    @ApiResponse(responseCode = "200", description = "Application is ready")
    @Get("/ready")
    public HttpResponse<Map<String, String>> ready() {
        return HttpResponse.ok(Map.of("status", "READY"));
    }
    
    @Operation(summary = "Check liveness")
    @ApiResponse(responseCode = "200", description = "Application is alive")
    @Get("/live")
    public HttpResponse<Map<String, String>> live() {
        return HttpResponse.ok(Map.of("status", "ALIVE"));
    }
}`
      },

      // Services
      {
        path: `src/main/java/${packagePath}/service/AuthService.java`,
        content: `package ${packageName}.service;

import ${packageName}.dto.LoginRequestDto;
import ${packageName}.dto.TokenResponseDto;
import ${packageName}.dto.UserRegistrationDto;
import ${packageName}.dto.UserResponseDto;
import ${packageName}.exception.InvalidCredentialsException;
import ${packageName}.exception.ResourceNotFoundException;
import ${packageName}.exception.UserAlreadyExistsException;
import ${packageName}.security.JwtTokenProvider;
import io.micronaut.security.authentication.UsernamePasswordCredentials;
import io.micronaut.security.token.jwt.generator.JwtTokenGenerator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jakarta.inject.Inject;
import jakarta.inject.Singleton;

@Singleton
public class AuthService {
    
    private static final Logger logger = LoggerFactory.getLogger(AuthService.class);
    
    @Inject
    private UserService userService;
    
    @Inject
    private JwtTokenProvider jwtTokenProvider;

    public TokenResponseDto register(UserRegistrationDto registrationDto) {
        logger.info("Registering new user with email: {}", registrationDto.getEmail());
        
        UserResponseDto user = userService.createUser(registrationDto);
        
        String accessToken = jwtTokenProvider.generateAccessToken(user.getEmail());
        String refreshToken = jwtTokenProvider.generateRefreshToken(user.getEmail());
        
        logger.info("User registered successfully: {}", user.getEmail());
        
        return new TokenResponseDto(accessToken, refreshToken, "Bearer", 3600, user);
    }
    
    public TokenResponseDto login(LoginRequestDto loginDto) {
        logger.info("Login attempt for email: {}", loginDto.getEmail());
        
        UserResponseDto user = userService.authenticateUser(loginDto.getEmail(), loginDto.getPassword());
        if (user == null) {
            logger.warn("Failed login attempt for email: {}", loginDto.getEmail());
            throw new InvalidCredentialsException("Invalid email or password");
        }
        
        String accessToken = jwtTokenProvider.generateAccessToken(user.getEmail());
        String refreshToken = jwtTokenProvider.generateRefreshToken(user.getEmail());
        
        logger.info("User logged in successfully: {}", user.getEmail());
        
        return new TokenResponseDto(accessToken, refreshToken, "Bearer", 3600, user);
    }
    
    public TokenResponseDto refreshToken(String refreshToken) {
        logger.info("Refreshing access token");
        
        String token = refreshToken.replace("Bearer ", "");
        
        if (!jwtTokenProvider.validateToken(token)) {
            logger.warn("Invalid refresh token provided");
            throw new InvalidCredentialsException("Invalid refresh token");
        }
        
        String email = jwtTokenProvider.getEmailFromToken(token);
        UserResponseDto user = userService.getUserByEmail(email);
        
        String newAccessToken = jwtTokenProvider.generateAccessToken(email);
        String newRefreshToken = jwtTokenProvider.generateRefreshToken(email);
        
        logger.info("Token refreshed successfully for user: {}", email);
        
        return new TokenResponseDto(newAccessToken, newRefreshToken, "Bearer", 3600, user);
    }
}`
      },

      // Repositories
      {
        path: `src/main/java/${packagePath}/repository/UserRepository.java`,
        content: `package ${packageName}.repository;

import ${packageName}.domain.User;
import io.micronaut.data.annotation.Repository;
import io.micronaut.data.jpa.repository.JpaRepository;
import io.micronaut.data.model.Page;
import io.micronaut.data.model.Pageable;

import java.util.Optional;
import java.util.UUID;

@Repository
public interface UserRepository extends JpaRepository<User, UUID> {
    
    Optional<User> findByEmail(String email);
    
    boolean existsByEmail(String email);
    
    Page<User> findAll(Pageable pageable);
    
    void deleteByEmail(String email);
}`
      },

      // Configuration
      {
        path: `src/main/java/${packagePath}/config/DatabaseConfiguration.java`,
        content: `package ${packageName}.config;

import io.micronaut.context.annotation.ConfigurationProperties;
import io.micronaut.context.annotation.Factory;
import io.micronaut.flyway.FlywayConfigurationProperties;
import jakarta.inject.Singleton;

@Factory
public class DatabaseConfiguration {

    @Singleton
    @ConfigurationProperties("flyway")
    public FlywayConfigurationProperties flywayConfiguration() {
        return new FlywayConfigurationProperties();
    }
}`
      },

      // Security
      {
        path: `src/main/java/${packagePath}/security/JwtTokenProvider.java`,
        content: `package ${packageName}.security;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import io.micronaut.context.annotation.Value;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jakarta.inject.Singleton;
import javax.crypto.SecretKey;
import java.util.Date;

@Singleton
public class JwtTokenProvider {
    
    private static final Logger logger = LoggerFactory.getLogger(JwtTokenProvider.class);
    
    private final SecretKey secretKey;
    private final long accessTokenExpiration;
    private final long refreshTokenExpiration;
    
    public JwtTokenProvider(
            @Value("\${micronaut.security.token.jwt.signatures.secret.generator.secret}") String secret,
            @Value("\${micronaut.security.token.jwt.generator.access-token.expiration:3600}") long accessTokenExpiration) {
        this.secretKey = Keys.hmacShaKeyFor(secret.getBytes());
        this.accessTokenExpiration = accessTokenExpiration * 1000; // Convert to milliseconds
        this.refreshTokenExpiration = accessTokenExpiration * 1000 * 24 * 7; // 7 days
    }
    
    public String generateAccessToken(String email) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + accessTokenExpiration);
        
        return Jwts.builder()
                .setSubject(email)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .claim("type", "access")
                .signWith(secretKey)
                .compact();
    }
    
    public String generateRefreshToken(String email) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + refreshTokenExpiration);
        
        return Jwts.builder()
                .setSubject(email)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .claim("type", "refresh")
                .signWith(secretKey)
                .compact();
    }
    
    public String getEmailFromToken(String token) {
        Claims claims = Jwts.parserBuilder()
                .setSigningKey(secretKey)
                .build()
                .parseClaimsJws(token)
                .getBody();
        
        return claims.getSubject();
    }
    
    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder()
                .setSigningKey(secretKey)
                .build()
                .parseClaimsJws(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            logger.error("Invalid JWT token: {}", e.getMessage());
            return false;
        }
    }
    
    public boolean isTokenExpired(String token) {
        try {
            Claims claims = Jwts.parserBuilder()
                    .setSigningKey(secretKey)
                    .build()
                    .parseClaimsJws(token)
                    .getBody();
            
            return claims.getExpiration().before(new Date());
        } catch (JwtException | IllegalArgumentException e) {
            return true;
        }
    }
}`
      },

      // Test configuration
      {
        path: `src/test/resources/application-test.yml`,
        content: `micronaut:
  application:
    name: ${this.options?.name || 'backend-api'}-test
  server:
    port: -1

datasources:
  default:
    url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    username: sa
    password: ""
    driver-class-name: org.h2.Driver
    dialect: H2

jpa:
  default:
    properties:
      hibernate:
        hbm2ddl:
          auto: create-drop
        show_sql: true

flyway:
  datasources:
    default:
      enabled: false

logger:
  levels:
    com.${this.sanitizeName(this.options?.name || 'example')}: DEBUG
    io.micronaut: DEBUG
`
      },

      // Integration test
      {
        path: `src/test/java/${packagePath}/integration/AuthControllerTest.java`,
        content: `package ${packageName}.integration;

import ${packageName}.dto.LoginRequestDto;
import ${packageName}.dto.TokenResponseDto;
import ${packageName}.dto.UserRegistrationDto;
import io.micronaut.http.HttpRequest;
import io.micronaut.http.HttpResponse;
import io.micronaut.http.HttpStatus;
import io.micronaut.http.client.HttpClient;
import io.micronaut.http.client.annotation.Client;
import io.micronaut.test.extensions.junit5.annotation.MicronautTest;
import org.junit.jupiter.api.Test;

import jakarta.inject.Inject;

import static org.junit.jupiter.api.Assertions.*;

@MicronautTest
public class AuthControllerTest {

    @Inject
    @Client("/")
    HttpClient client;

    @Test
    public void testUserRegistrationAndLogin() {
        // Test user registration
        UserRegistrationDto registrationDto = new UserRegistrationDto(
            "John", "Doe", "john.doe@example.com", "password123"
        );
        
        HttpRequest<UserRegistrationDto> registerRequest = HttpRequest.POST("/api/v1/auth/register", registrationDto);
        HttpResponse<TokenResponseDto> registerResponse = client.toBlocking().exchange(registerRequest, TokenResponseDto.class);
        
        assertEquals(HttpStatus.CREATED, registerResponse.getStatus());
        assertNotNull(registerResponse.body());
        assertNotNull(registerResponse.body().getAccessToken());
        
        // Test user login
        LoginRequestDto loginDto = new LoginRequestDto("john.doe@example.com", "password123");
        
        HttpRequest<LoginRequestDto> loginRequest = HttpRequest.POST("/api/v1/auth/login", loginDto);
        HttpResponse<TokenResponseDto> loginResponse = client.toBlocking().exchange(loginRequest, TokenResponseDto.class);
        
        assertEquals(HttpStatus.OK, loginResponse.getStatus());
        assertNotNull(loginResponse.body());
        assertNotNull(loginResponse.body().getAccessToken());
    }
    
    @Test
    public void testHealthEndpoint() {
        HttpRequest<String> request = HttpRequest.GET("/api/v1/health");
        HttpResponse<String> response = client.toBlocking().exchange(request, String.class);
        
        assertEquals(HttpStatus.OK, response.getStatus());
        assertTrue(response.body().contains("UP"));
    }
}`
      }
    ];

    // Write all files
    for (const file of files) {
      await fs.writeFile(path.join(projectPath, file.path), file.content);
    }
  }
}