import { BackendTemplate } from '../types';

export const haskellStackTemplate: BackendTemplate = {
  id: 'haskell-stack',
  name: 'haskell-stack',
  displayName: 'Haskell Stack Build System',
  description: 'A batteries-included Haskell project with Stack build system, featuring reproducible builds and curated package sets',
  framework: 'stack',
  language: 'haskell',
  version: '2.13',
  author: 'Re-Shell Team',
  featured: true,
  recommended: true,
  icon: 'ðŸ”§',
  type: 'build-tool',
  complexity: 'beginner',
  keywords: ['haskell', 'stack', 'build-system', 'package-management', 'reproducible'],
  
  features: [
    'Reproducible builds with Stackage',
    'Curated package sets',
    'Isolated build environments',
    'Docker integration',
    'Multi-package projects',
    'GHCi with automatic reloading',
    'Test and benchmark support',
    'Coverage reports',
    'Profiling configuration',
    'Cross-platform support',
    'IDE integration',
    'Script interpreter',
    'Dependency visualization',
    'Upload to Hackage'
  ],
  
  structure: {
    'stack.yaml': `# Stack configuration
resolver: lts-21.0

# User packages to be built
packages:
- .

# Extra dependencies not in the resolver
extra-deps:
- acme-missiles-0.3@sha256:2ba66a092a32593880a87fb00f3213762d7bca65a687d45965778deb8694c5d1,613
- github: owner/repo
  commit: abc123def456

# Override default flag values for local packages and extra-deps
flags:
  my-project:
    developer-mode: true
    use-katip: true

# Extra package databases containing global packages
extra-package-dbs: []

# Control whether we use the GHC we find on the PATH
system-ghc: false

# Require a specific version of Stack
require-stack-version: ">= 2.13"

# Enable Docker for builds
docker:
  enable: false
  repo: fpco/stack-build:lts-21.0

# Extra directories used by Stack for building
extra-include-dirs: []
extra-lib-dirs: []

# Allow a newer minor version of GHC than the snapshot specifies
compiler-check: newer-minor

# Nix integration
nix:
  enable: false
  packages: []

# Build output options
build:
  library-profiling: false
  executable-profiling: false
  copy-bins: true
  prefetch: true
  keep-tmp-files: false
  
# Test options  
test:
  coverage: false
  no-run-tests: false

# Benchmark options
benchmark:
  no-run-benchmarks: false

# Options passed to GHC
ghc-options:
  "$everything": -haddock
  "$locals": -Wall -Wcompat -Widentities

# Extra directories to watch for changes
extra-source-files:
- README.md
- CHANGELOG.md`,

    'stack.yaml.lock': `# This file was autogenerated by Stack.
# You should not edit this file by hand.
# For more information, please see the documentation at:
#   https://docs.haskellstack.org/en/stable/lock_files

packages:
- completed:
    hackage: acme-missiles-0.3@sha256:2ba66a092a32593880a87fb00f3213762d7bca65a687d45965778deb8694c5d1,613
    pantry-tree:
      sha256: 7b8b5c3b7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e
      size: 456
  original:
    hackage: acme-missiles-0.3@sha256:2ba66a092a32593880a87fb00f3213762d7bca65a687d45965778deb8694c5d1,613
snapshots:
- completed:
    sha256: 7d4b062e39f4c7e8b7e8b5c3b7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e
    size: 640042
    url: https://raw.githubusercontent.com/commercialhaskell/stackage-snapshots/master/lts/21/0.yaml
  original: lts-21.0`,

    'package.yaml': `name:                my-stack-project
version:             0.1.0.0
github:              "githubuser/my-stack-project"
license:             MIT
author:              "Your Name"
maintainer:          "your.email@example.com"
copyright:           "2024 Your Name"

extra-source-files:
- README.md
- CHANGELOG.md

# Metadata used when publishing your package
synopsis:            A Stack-based Haskell project
category:            Application

# To avoid duplicated efforts in documentation and dealing with the
# complications of embedding Haddock markup inside cabal files, it is
# common to point users to the README.md file.
description:         Please see the README on GitHub at <https://github.com/githubuser/my-stack-project#readme>

dependencies:
- base >= 4.7 && < 5

ghc-options:
- -Wall
- -Wcompat
- -Widentities
- -Wincomplete-record-updates
- -Wincomplete-uni-patterns
- -Wmissing-export-lists
- -Wmissing-home-modules
- -Wpartial-fields
- -Wredundant-constraints

default-extensions:
- ConstraintKinds
- DeriveGeneric
- DerivingStrategies
- GeneralizedNewtypeDeriving
- InstanceSigs
- KindSignatures
- LambdaCase
- OverloadedStrings
- RecordWildCards
- ScopedTypeVariables
- StandaloneDeriving
- TupleSections
- TypeApplications
- ViewPatterns

library:
  source-dirs: src
  dependencies:
  - aeson
  - bytestring
  - containers
  - mtl
  - text
  - time
  - transformers

executables:
  my-stack-project-exe:
    main:                Main.hs
    source-dirs:         app
    ghc-options:
    - -threaded
    - -rtsopts
    - -with-rtsopts=-N
    dependencies:
    - my-stack-project
    - optparse-applicative

tests:
  my-stack-project-test:
    main:                Spec.hs
    source-dirs:         test
    ghc-options:
    - -threaded
    - -rtsopts
    - -with-rtsopts=-N
    dependencies:
    - my-stack-project
    - hspec
    - hspec-discover
    - QuickCheck

benchmarks:
  my-stack-project-bench:
    main:                Bench.hs
    source-dirs:         bench
    ghc-options:
    - -threaded
    - -rtsopts
    - -with-rtsopts=-N
    dependencies:
    - my-stack-project
    - criterion
    - deepseq`,

    'Setup.hs': `import Distribution.Simple
main = defaultMain`,

    'src/Lib.hs': `{-# LANGUAGE OverloadedStrings #-}

-- | Main library module
module Lib
    ( -- * Main entry point
      someFunc
    , runApp
    , Config(..)
    , defaultConfig
    
      -- * Core types
    , AppState(..)
    , AppError(..)
    , AppM
    
      -- * Utilities
    , logInfo
    , logError
    ) where

import Control.Monad.Reader
import Control.Monad.Except
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.IO as TIO

-- | Application configuration
data Config = Config
    { configPort :: Int
    , configHost :: String
    , configDebug :: Bool
    } deriving (Eq, Show)

-- | Default configuration
defaultConfig :: Config
defaultConfig = Config
    { configPort = 3000
    , configHost = "localhost"
    , configDebug = False
    }

-- | Application state
data AppState = AppState
    { appConfig :: Config
    , appStartTime :: UTCTime
    } deriving (Show)

-- | Application errors
data AppError
    = ConfigError Text
    | RuntimeError Text
    | ValidationError Text
    deriving (Eq, Show)

-- | Application monad
type AppM = ReaderT AppState (ExceptT AppError IO)

-- | Run the application
runApp :: Config -> IO (Either AppError ())
runApp config = do
    now <- getCurrentTime
    let state = AppState config now
    runExceptT $ runReaderT app state
  where
    app = do
        logInfo "Starting application..."
        -- Your application logic here
        logInfo "Application started successfully"

-- | Example function
someFunc :: IO ()
someFunc = do
    result <- runApp defaultConfig
    case result of
        Left err -> putStrLn $ "Error: " ++ show err
        Right () -> putStrLn "Success!"

-- | Log an info message
logInfo :: Text -> AppM ()
logInfo msg = do
    debug <- asks (configDebug . appConfig)
    when debug $ liftIO $ TIO.putStrLn $ "[INFO] " <> msg

-- | Log an error message
logError :: Text -> AppM ()
logError msg = liftIO $ TIO.putStrLn $ "[ERROR] " <> msg`,

    'app/Main.hs': `{-# LANGUAGE ApplicativeDo #-}
{-# LANGUAGE RecordWildCards #-}

module Main (main) where

import Lib
import Options.Applicative
import Data.Semigroup ((<>))

-- | Command line arguments
data Options = Options
    { optPort :: Int
    , optHost :: String
    , optDebug :: Bool
    , optCommand :: Command
    } deriving (Show)

-- | Application commands
data Command
    = Serve
    | Check
    | Migrate
    | Version
    deriving (Show)

-- | Parse command line options
parseOptions :: Parser Options
parseOptions = do
    optPort <- option auto
        ( long "port"
       <> short 'p'
       <> metavar "PORT"
       <> value 3000
       <> help "Port to listen on"
        )
    
    optHost <- strOption
        ( long "host"
       <> short 'h'
       <> metavar "HOST"
       <> value "localhost"
       <> help "Host to bind to"
        )
    
    optDebug <- switch
        ( long "debug"
       <> short 'd'
       <> help "Enable debug logging"
        )
    
    optCommand <- subparser
        ( command "serve"
            (info (pure Serve) (progDesc "Start the server"))
       <> command "check"
            (info (pure Check) (progDesc "Check configuration"))
       <> command "migrate"
            (info (pure Migrate) (progDesc "Run database migrations"))
       <> command "version"
            (info (pure Version) (progDesc "Show version information"))
        )
    
    pure Options{..}

-- | Main entry point
main :: IO ()
main = do
    opts <- execParser opts'
    let config = Config
            { configPort = optPort opts
            , configHost = optHost opts
            , configDebug = optDebug opts
            }
    
    case optCommand opts of
        Serve -> do
            putStrLn $ "Starting server on " ++ optHost opts ++ ":" ++ show (optPort opts)
            result <- runApp config
            case result of
                Left err -> putStrLn $ "Server error: " ++ show err
                Right () -> putStrLn "Server stopped"
        
        Check -> 
            putStrLn "Configuration is valid"
        
        Migrate ->
            putStrLn "Running migrations..."
        
        Version ->
            putStrLn "my-stack-project version 0.1.0.0"
  where
    opts' = info (parseOptions <**> helper)
        ( fullDesc
       <> progDesc "A Stack-based Haskell application"
       <> header "my-stack-project - built with Stack"
        )`,

    'test/Spec.hs': `{-# OPTIONS_GHC -F -pgmF hspec-discover #-}
-- This file is auto-discovered by hspec-discover
-- It will automatically find and run all *Spec.hs files`,

    'test/LibSpec.hs': `{-# LANGUAGE OverloadedStrings #-}

module LibSpec (spec) where

import Test.Hspec
import Test.QuickCheck
import Lib

spec :: Spec
spec = do
  describe "Config" $ do
    it "has sensible defaults" $ do
      configPort defaultConfig \`shouldBe\` 3000
      configHost defaultConfig \`shouldBe\` "localhost"
      configDebug defaultConfig \`shouldBe\` False
    
    prop "port is always positive" $ \\port ->
      port > 0 ==> configPort (defaultConfig { configPort = port }) > 0
  
  describe "runApp" $ do
    it "runs successfully with default config" $ do
      result <- runApp defaultConfig
      result \`shouldBe\` Right ()
    
    it "handles invalid configuration gracefully" $ do
      let badConfig = defaultConfig { configPort = -1 }
      result <- runApp badConfig
      case result of
        Left (ConfigError _) -> return ()
        _ -> expectationFailure "Expected ConfigError"`,

    'bench/Bench.hs': `{-# LANGUAGE OverloadedStrings #-}

module Main (main) where

import Criterion.Main
import Lib

-- | Benchmark suite
main :: IO ()
main = defaultMain
    [ bgroup "Config"
        [ bench "defaultConfig" $ whnf (const defaultConfig) ()
        ]
    
    , bgroup "App"
        [ bench "runApp" $ whnfAppIO (runApp defaultConfig)
        ]
    ]`,

    '.github/workflows/ci.yml': `name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 2 * * 0' # Weekly on Sundays at 02:00

jobs:
  stack:
    name: Stack ${{ matrix.stack }} - ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        stack: ['2.13']
        os: [ubuntu-latest, macOS-latest, windows-latest]
    
    steps:
    - uses: actions/checkout@v3
    
    - uses: haskell/actions/setup@v2
      with:
        enable-stack: true
        stack-version: ${{ matrix.stack }}
    
    - name: Cache Stack dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.stack
          .stack-work
        key: ${{ runner.os }}-stack-${{ hashFiles('stack.yaml', 'package.yaml') }}
        restore-keys: |
          ${{ runner.os }}-stack-
    
    - name: Install dependencies
      run: |
        stack setup
        stack build --dependencies-only --test --bench --no-run-tests --no-run-benchmarks
    
    - name: Build
      run: stack build --test --bench --no-run-tests --no-run-benchmarks
    
    - name: Run tests
      run: stack test
    
    - name: Run benchmarks
      run: stack bench --no-run-benchmarks
    
    - name: Generate documentation
      run: stack haddock
    
    - name: Check code formatting
      if: matrix.os == 'ubuntu-latest'
      run: |
        stack install fourmolu
        stack exec -- fourmolu --mode check src app test
    
    - name: Lint with HLint
      if: matrix.os == 'ubuntu-latest'
      run: |
        stack install hlint
        stack exec -- hlint src app test

  coverage:
    name: Test Coverage
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - uses: haskell/actions/setup@v2
      with:
        enable-stack: true
    
    - name: Run tests with coverage
      run: |
        stack test --coverage
        stack hpc report .
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        files: ./coverage/lcov.info`,

    'Makefile': `# Makefile for Stack project

.PHONY: all build test bench doc clean install run repl watch format lint setup docker release

# Default target
all: build

# Setup development environment
setup:
	stack setup
	stack build --dependencies-only --test --bench
	stack install hlint fourmolu hoogle

# Build the project
build:
	stack build --fast

# Build with profiling
build-profile:
	stack build --profile

# Run tests
test:
	stack test

# Run tests with coverage
test-coverage:
	stack test --coverage
	stack hpc report .

# Run benchmarks
bench:
	stack bench

# Generate documentation
doc:
	stack haddock
	stack hoogle -- generate --local

# Clean build artifacts
clean:
	stack clean
	rm -rf .stack-work

# Install the executable
install:
	stack install

# Run the application
run:
	stack run

# Start REPL
repl:
	stack ghci

# Watch for changes and rebuild
watch:
	stack build --file-watch --fast

# Format code
format:
	stack exec -- fourmolu --mode inplace src app test

# Check formatting
format-check:
	stack exec -- fourmolu --mode check src app test

# Lint code
lint:
	stack exec -- hlint src app test

# Build Docker image
docker:
	stack image container

# Create a release
release:
	stack build --test
	stack sdist
	stack upload .

# Run with profiling
profile:
	stack run --profile -- +RTS -p

# Update dependencies
update:
	stack update
	stack list-dependencies --depth 0 | grep -v "^my-" | awk '{print $$1}' | xargs -I {} stack list-dependencies {} --depth 0

# Generate ctags
tags:
	stack exec -- hasktags -c src

# Run GHCi with all warnings
ghci-warnings:
	stack ghci --ghci-options "-Wall"

# Check for outdated dependencies
outdated:
	stack list-dependencies --depth 0 | grep -v "^my-"`,

    '.gitignore': `# Stack
.stack-work/
*~
*.cabal
stack.yaml.lock

# Haskell
dist
dist-*
cabal-dev
*.o
*.hi
*.hie
*.chi
*.chs.h
*.dyn_o
*.dyn_hi
.hpc
.hsenv
.cabal-sandbox/
cabal.sandbox.config
*.prof
*.aux
*.hp
*.eventlog
.HTF/
.ghc.environment.*

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Project specific
tags
TAGS
.hoogle/
*.tix`,

    'hie.yaml': `# HLS (Haskell Language Server) configuration for Stack projects
cradle:
  stack:
    - path: "./src"
      component: "my-stack-project:lib"
    
    - path: "./app"
      component: "my-stack-project:exe:my-stack-project-exe"
    
    - path: "./test"
      component: "my-stack-project:test:my-stack-project-test"
    
    - path: "./bench"
      component: "my-stack-project:bench:my-stack-project-bench"`,

    'fourmolu.yaml': `# Fourmolu configuration
indentation: 2
column-limit: 100
function-arrows: leading
comma-style: leading
import-export-style: leading
indent-wheres: true
record-brace-space: true
newlines-between-decls: 1
haddock-style: multi-line
let-style: inline
in-style: right-align
unicode: never
respectful: true`,

    '.hlint.yaml': `# HLint configuration
- arguments: [--color=auto]

# Warnings to ignore
- ignore: {name: "Redundant do"}
- ignore: {name: "Use newtype instead of data"}
- ignore: {name: "Use camelCase"}

# Custom warnings
- warn: {lhs: "map f (map g x)", rhs: "map (f . g) x"}
- error: {lhs: "foldr f z (map g x)", rhs: "foldr (f . g) z x"}

# Suggestions
- suggest: {lhs: "null x", rhs: "Data.null x"}

# Module restrictions
- modules:
  - {name: [Data.Set, Data.HashSet], as: Set}
  - {name: [Data.Map, Data.HashMap], as: Map}
  
# Custom operators
- fixity: "infixr 9 ."
- fixity: "infixl 4 <$>"
- fixity: "infixl 4 <*>"`,

    'README.md': `# My Stack Project

A modern Haskell project built with Stack for reproducible builds.

## Features

- Stack build system with reproducible builds
- Stackage LTS for curated package sets
- Comprehensive testing with HSpec and QuickCheck
- Benchmarking with Criterion
- Code formatting with Fourmolu
- Linting with HLint
- CI/CD with GitHub Actions
- Docker support
- IDE integration (VSCode, IntelliJ)
- Cross-platform support

## Prerequisites

- [Stack](https://docs.haskellstack.org/en/stable/install_and_upgrade/)
- Git

## Quick Start

1. **Clone and setup**
   \`\`\`bash
   git clone <repository-url>
   cd my-stack-project
   make setup
   \`\`\`

2. **Build the project**
   \`\`\`bash
   stack build
   # or for faster builds during development
   make build
   \`\`\`

3. **Run tests**
   \`\`\`bash
   stack test
   # or with coverage
   make test-coverage
   \`\`\`

4. **Run the application**
   \`\`\`bash
   stack run -- serve --debug
   # or
   make run
   \`\`\`

## Project Structure

\`\`\`
.
â”œâ”€â”€ app/                 # Executable source
â”‚   â””â”€â”€ Main.hs
â”œâ”€â”€ src/                 # Library source
â”‚   â””â”€â”€ Lib.hs
â”œâ”€â”€ test/               # Test suite
â”‚   â”œâ”€â”€ Spec.hs
â”‚   â””â”€â”€ LibSpec.hs
â”œâ”€â”€ bench/              # Benchmarks
â”‚   â””â”€â”€ Bench.hs
â”œâ”€â”€ stack.yaml          # Stack configuration
â”œâ”€â”€ package.yaml        # Package description (hpack)
â”œâ”€â”€ Setup.hs           # Cabal setup file
â”œâ”€â”€ hie.yaml           # HLS configuration
â”œâ”€â”€ fourmolu.yaml      # Code formatter config
â”œâ”€â”€ .hlint.yaml        # Linter configuration
â””â”€â”€ Makefile           # Build automation
\`\`\`

## Development

### Interactive Development

Start GHCi with automatic reloading:
\`\`\`bash
stack build --file-watch --fast
\`\`\`

Or use the REPL:
\`\`\`bash
make repl
\`\`\`

### Code Style

Format code:
\`\`\`bash
make format
\`\`\`

Check linting:
\`\`\`bash
make lint
\`\`\`

### Testing

Run all tests:
\`\`\`bash
stack test
\`\`\`

Run tests with file watching:
\`\`\`bash
stack test --file-watch
\`\`\`

Generate coverage report:
\`\`\`bash
make test-coverage
\`\`\`

### Benchmarking

Run benchmarks:
\`\`\`bash
make bench
\`\`\`

### Documentation

Generate documentation:
\`\`\`bash
stack haddock
\`\`\`

### Profiling

Build with profiling:
\`\`\`bash
make build-profile
\`\`\`

Run with profiling:
\`\`\`bash
make profile
\`\`\`

## Stack Commands

### Common commands

- \`stack build\` - Build the project
- \`stack test\` - Run tests
- \`stack run\` - Run the executable
- \`stack ghci\` - Start GHCi REPL
- \`stack clean\` - Clean build artifacts
- \`stack hoogle\` - Search documentation

### Dependency management

- \`stack update\` - Update package index
- \`stack list-dependencies\` - Show dependencies
- \`stack exec -- ghc-pkg list\` - List installed packages

### Docker integration

Build and run in Docker:
\`\`\`bash
stack build --docker
stack run --docker
\`\`\`

## CI/CD

The project includes GitHub Actions workflows for:
- Building on multiple platforms (Linux, macOS, Windows)
- Running tests and benchmarks
- Code formatting and linting checks
- Coverage reporting
- Documentation generation

## Scripts

Stack can also run Haskell scripts:
\`\`\`haskell
#!/usr/bin/env stack
-- stack --resolver lts-21.0 script
main = putStrLn "Hello from Stack script!"
\`\`\`

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Run tests and linting
5. Submit a pull request

## License

MIT License - see LICENSE file for details`,

    'CHANGELOG.md': `# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- Initial project setup with Stack
- Basic library structure
- Test suite with HSpec
- Benchmarks with Criterion
- CI/CD with GitHub Actions
- Docker support
- Code formatting and linting

### Changed
- Nothing yet

### Deprecated
- Nothing yet

### Removed
- Nothing yet

### Fixed
- Nothing yet

### Security
- Nothing yet

## [0.1.0.0] - 2024-01-01

### Added
- Initial release`,

    'LICENSE': `MIT License

Copyright (c) 2024 Your Name

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.`
  }
};