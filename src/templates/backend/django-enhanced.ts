import { BackendTemplate } from '../types';

export const djangoEnhancedTemplate: BackendTemplate = {
  name: 'django-enhanced',
  displayName: 'Django Enhanced',
  description: 'Django with enhanced ORM management commands and migration utilities',
  framework: 'django',
  language: 'python',
  dependencies: {
    'Django': '>=4.2.0,<5.0',
    'django-extensions': '^3.2.3',
    'djangorestframework': '^3.14.0',
    'django-filter': '^23.2',
    'python-decouple': '^3.8',
    'psycopg2-binary': '^2.9.7',
    'redis': '^4.6.0',
    'celery': '^5.3.1',
    'flower': '^2.0.1',
    'gunicorn': '^21.2.0',
    'whitenoise': '^6.5.0',
  },
  devDependencies: {
    'pytest': '^7.4.0',
    'pytest-django': '^4.5.2',
    'pytest-cov': '^4.1.0',
    'factory-boy': '^3.3.0',
    'black': '^23.7.0',
    'isort': '^5.12.0',
    'flake8': '^6.0.0',
    'mypy': '^1.5.0',
    'django-debug-toolbar': '^4.1.0',
    'django-silk': '^5.0.3',
  },

  generate(projectName: string): Record<string, string> {
    const files: Record<string, string> = {};

    // Django ORM Enhancement Manager
    files[`${projectName}/management/__init__.py`] = '';
    files[`${projectName}/management/commands/__init__.py`] = '';

    // Create Data Migration Command
    files[`${projectName}/management/commands/create_data_migration.py`] = `"""
Custom management command to create data migration with template.
"""
from django.core.management.base import BaseCommand, CommandError
from django.core.management import call_command
from django.apps import apps
import os


class Command(BaseCommand):
    help = 'Create a data migration with enhanced template'

    def add_arguments(self, parser):
        parser.add_argument('app_label', type=str, help='App label for the migration')
        parser.add_argument('migration_name', type=str, help='Name of the migration')
        parser.add_argument(
            '--model',
            type=str,
            help='Model name to include in migration template'
        )
        parser.add_argument(
            '--operation',
            choices=['create', 'update', 'delete', 'custom'],
            default='custom',
            help='Type of data operation'
        )

    def handle(self, *args, **options):
        app_label = options['app_label']
        migration_name = options['migration_name']
        model_name = options.get('model', '')
        operation = options['operation']

        # Validate app exists
        try:
            apps.get_app_config(app_label)
        except LookupError:
            raise CommandError(f'App "{app_label}" not found')

        # Create empty migration
        call_command('makemigrations', app_label, '--empty', '--name', migration_name)

        # Get the migration file path
        migrations_dir = apps.get_app_config(app_label).path + '/migrations'
        migration_files = [f for f in os.listdir(migrations_dir) 
                          if f.endswith('.py') and migration_name in f]
        
        if not migration_files:
            raise CommandError('Migration file not created')

        migration_file = os.path.join(migrations_dir, migration_files[0])

        # Generate migration template based on operation type
        template = self.get_migration_template(operation, model_name, app_label)

        # Replace the empty migration with our template
        with open(migration_file, 'w') as f:
            f.write(template)

        self.stdout.write(
            self.style.SUCCESS(
                f'Created data migration: {migration_file}\\n'
                f'Operation type: {operation}\\n'
                f'Remember to implement the forward and reverse operations!'
            )
        )

    def get_migration_template(self, operation: str, model_name: str, app_label: str) -> str:
        """Generate migration template based on operation type."""
        
        if operation == 'create':
            return f'''# Generated by Re-Shell Django ORM Manager
from django.db import migrations
from django.conf import settings


def create_{model_name.lower()}_data(apps, schema_editor):
    """Forward data migration - create {model_name} data."""
    {model_name} = apps.get_model('{app_label}', '{model_name}')
    
    # TODO: Implement data creation logic
    # Example:
    # {model_name}.objects.bulk_create([
    #     {model_name}(field1='value1', field2='value2'),
    #     # Add more instances as needed
    # ])
    pass


def reverse_{model_name.lower()}_data(apps, schema_editor):
    """Reverse data migration - remove {model_name} data."""
    {model_name} = apps.get_model('{app_label}', '{model_name}')
    
    # TODO: Implement data removal logic
    # Example:
    # {model_name}.objects.filter(field1='value1').delete()
    pass


class Migration(migrations.Migration):
    dependencies = [
        # TODO: Add dependency to the latest migration in this app
        ('{app_label}', '0001_initial'),
    ]

    operations = [
        migrations.RunPython(
            create_{model_name.lower()}_data,
            reverse_{model_name.lower()}_data,
        ),
    ]
'''
        elif operation == 'update':
            return f'''# Generated by Re-Shell Django ORM Manager
from django.db import migrations


def update_{model_name.lower()}_data(apps, schema_editor):
    """Forward data migration - update {model_name} data."""
    {model_name} = apps.get_model('{app_label}', '{model_name}')
    
    # TODO: Implement data update logic
    # Example:
    # {model_name}.objects.filter(old_field='old_value').update(
    #     new_field='new_value'
    # )
    pass


def reverse_{model_name.lower()}_data(apps, schema_editor):
    """Reverse data migration - revert {model_name} data updates."""
    {model_name} = apps.get_model('{app_label}', '{model_name}')
    
    # TODO: Implement data reversion logic
    # Example:
    # {model_name}.objects.filter(new_field='new_value').update(
    #     old_field='old_value'
    # )
    pass


class Migration(migrations.Migration):
    dependencies = [
        ('{app_label}', '0001_initial'),
    ]

    operations = [
        migrations.RunPython(
            update_{model_name.lower()}_data,
            reverse_{model_name.lower()}_data,
        ),
    ]
'''
        else:  # custom
            return f'''# Generated by Re-Shell Django ORM Manager
from django.db import migrations


def forward_migration(apps, schema_editor):
    """Forward data migration logic."""
    # TODO: Implement forward migration logic
    # Get models like this:
    # Model = apps.get_model('{app_label}', 'ModelName')
    pass


def reverse_migration(apps, schema_editor):
    """Reverse data migration logic."""
    # TODO: Implement reverse migration logic
    pass


class Migration(migrations.Migration):
    dependencies = [
        ('{app_label}', '0001_initial'),
    ]

    operations = [
        migrations.RunPython(
            forward_migration,
            reverse_migration,
        ),
    ]
'''
`;

    // Reset Migrations Command
    files[`${projectName}/management/commands/reset_migrations.py`] = `"""
Management command to reset migrations for development.
"""
from django.core.management.base import BaseCommand, CommandError
from django.core.management import call_command
from django.apps import apps
from django.db import connection
import os
import shutil


class Command(BaseCommand):
    help = 'Reset migrations for one or all apps (development only)'

    def add_arguments(self, parser):
        parser.add_argument(
            'app_labels',
            nargs='*',
            help='App labels to reset (leave empty for all apps)'
        )
        parser.add_argument(
            '--confirm',
            action='store_true',
            help='Confirm the operation (required for safety)'
        )
        parser.add_argument(
            '--keep-initial',
            action='store_true',
            help='Keep the initial migration files'
        )

    def handle(self, *args, **options):
        if not options['confirm']:
            raise CommandError(
                'This command will delete migration files and database data. '
                'Use --confirm to proceed.'
            )

        app_labels = options['app_labels']
        keep_initial = options['keep_initial']

        if not app_labels:
            # Get all local app labels
            app_labels = [
                app.label for app in apps.get_app_configs()
                if not app.name.startswith('django.')
                and not app.name.startswith('rest_framework')
            ]

        for app_label in app_labels:
            self.reset_app_migrations(app_label, keep_initial)

        self.stdout.write(
            self.style.SUCCESS(
                f'Successfully reset migrations for: {", ".join(app_labels)}'
            )
        )

    def reset_app_migrations(self, app_label: str, keep_initial: bool):
        """Reset migrations for a specific app."""
        try:
            app_config = apps.get_app_config(app_label)
        except LookupError:
            raise CommandError(f'App "{app_label}" not found')

        migrations_dir = os.path.join(app_config.path, 'migrations')
        
        if not os.path.exists(migrations_dir):
            self.stdout.write(f'No migrations directory for {app_label}')
            return

        # Remove migration records from database
        with connection.cursor() as cursor:
            cursor.execute(
                "DELETE FROM django_migrations WHERE app = %s",
                [app_label]
            )

        # Remove migration files
        for filename in os.listdir(migrations_dir):
            if filename.endswith('.py') and filename != '__init__.py':
                if keep_initial and filename.startswith('0001_initial'):
                    continue
                
                file_path = os.path.join(migrations_dir, filename)
                os.remove(file_path)
                self.stdout.write(f'Removed {file_path}')

        # Remove __pycache__
        pycache_dir = os.path.join(migrations_dir, '__pycache__')
        if os.path.exists(pycache_dir):
            shutil.rmtree(pycache_dir)

        self.stdout.write(f'Reset migrations for {app_label}')
`;

    // Migration Status Command
    files[`${projectName}/management/commands/migration_status.py`] = `"""
Management command to show detailed migration status.
"""
from django.core.management.base import BaseCommand
from django.db.migrations.loader import MigrationLoader
from django.db import connection
from django.apps import apps
import sys


class Command(BaseCommand):
    help = 'Show detailed migration status for apps'

    def add_arguments(self, parser):
        parser.add_argument(
            'app_labels',
            nargs='*',
            help='App labels to check (leave empty for all apps)'
        )
        parser.add_argument(
            '--verbose',
            action='store_true',
            help='Show detailed information about each migration'
        )

    def handle(self, *args, **options):
        app_labels = options['app_labels']
        verbose = options['verbose']

        loader = MigrationLoader(connection)
        
        if not app_labels:
            app_labels = sorted(loader.migrated_apps)

        for app_label in app_labels:
            self.show_app_status(app_label, loader, verbose)

    def show_app_status(self, app_label: str, loader: MigrationLoader, verbose: bool):
        """Show migration status for a specific app."""
        try:
            app_config = apps.get_app_config(app_label)
        except LookupError:
            self.stdout.write(
                self.style.ERROR(f'App "{app_label}" not found')
            )
            return

        migrations = loader.disk_migrations
        applied_migrations = loader.applied_migrations

        app_migrations = [
            (name, migration) for (app, name), migration in migrations.items()
            if app == app_label
        ]

        if not app_migrations:
            self.stdout.write(f'No migrations found for {app_label}')
            return

        self.stdout.write(f'\\n=== {app_label.upper()} ===')
        
        applied_count = 0
        unapplied_count = 0

        for name, migration in sorted(app_migrations):
            migration_key = (app_label, name)
            is_applied = migration_key in applied_migrations

            if is_applied:
                status = self.style.SUCCESS('✓ APPLIED')
                applied_count += 1
            else:
                status = self.style.ERROR('✗ UNAPPLIED')
                unapplied_count += 1

            self.stdout.write(f'  {status} {name}')

            if verbose:
                # Show dependencies
                if migration.dependencies:
                    self.stdout.write('    Dependencies:')
                    for dep_app, dep_name in migration.dependencies:
                        self.stdout.write(f'      - {dep_app}.{dep_name}')
                
                # Show operations
                if hasattr(migration, 'operations') and migration.operations:
                    self.stdout.write('    Operations:')
                    for op in migration.operations:
                        self.stdout.write(f'      - {op.__class__.__name__}')

        summary = f'Total: {len(app_migrations)}, Applied: {applied_count}, Unapplied: {unapplied_count}'
        if unapplied_count > 0:
            self.stdout.write(self.style.WARNING(f'  {summary}'))
        else:
            self.stdout.write(self.style.SUCCESS(f'  {summary}'))
`;

    // Model Graph Command
    files[`${projectName}/management/commands/model_graph.py`] = `"""
Management command to generate model relationship graphs.
"""
from django.core.management.base import BaseCommand, CommandError
from django.apps import apps
from django.db import models
import os
import json


class Command(BaseCommand):
    help = 'Generate model relationship graph in various formats'

    def add_arguments(self, parser):
        parser.add_argument(
            'app_labels',
            nargs='*',
            help='App labels to include (leave empty for all apps)'
        )
        parser.add_argument(
            '--format',
            choices=['dot', 'mermaid', 'json'],
            default='dot',
            help='Output format (default: dot)'
        )
        parser.add_argument(
            '--output',
            type=str,
            help='Output file path (prints to stdout if not specified)'
        )
        parser.add_argument(
            '--include-fields',
            action='store_true',
            help='Include field details in the graph'
        )

    def handle(self, *args, **options):
        app_labels = options['app_labels']
        output_format = options['format']
        output_file = options['output']
        include_fields = options['include_fields']

        if not app_labels:
            app_labels = [
                app.label for app in apps.get_app_configs()
                if not app.name.startswith('django.')
                and not app.name.startswith('rest_framework')
            ]

        models_data = self.analyze_models(app_labels, include_fields)
        
        if output_format == 'dot':
            output = self.generate_dot_graph(models_data, include_fields)
        elif output_format == 'mermaid':
            output = self.generate_mermaid_graph(models_data, include_fields)
        else:  # json
            output = json.dumps(models_data, indent=2, default=str)

        if output_file:
            with open(output_file, 'w') as f:
                f.write(output)
            self.stdout.write(
                self.style.SUCCESS(f'Graph saved to {output_file}')
            )
        else:
            self.stdout.write(output)

    def analyze_models(self, app_labels: list, include_fields: bool) -> dict:
        """Analyze model relationships."""
        models_data = {
            'apps': {},
            'relationships': []
        }

        for app_label in app_labels:
            try:
                app_config = apps.get_app_config(app_label)
            except LookupError:
                continue

            app_models = {}
            
            for model in app_config.get_models():
                model_name = model.__name__
                model_info = {
                    'name': model_name,
                    'table': model._meta.db_table,
                    'abstract': model._meta.abstract,
                    'fields': []
                }

                if include_fields:
                    for field in model._meta.get_fields():
                        field_info = {
                            'name': field.name,
                            'type': field.__class__.__name__,
                            'null': getattr(field, 'null', False),
                            'blank': getattr(field, 'blank', False),
                        }
                        
                        if hasattr(field, 'max_length') and field.max_length:
                            field_info['max_length'] = field.max_length
                        
                        model_info['fields'].append(field_info)

                # Analyze relationships
                for field in model._meta.get_fields():
                    if isinstance(field, (models.ForeignKey, models.OneToOneField)):
                        models_data['relationships'].append({
                            'from_app': app_label,
                            'from_model': model_name,
                            'from_field': field.name,
                            'to_app': field.related_model._meta.app_label,
                            'to_model': field.related_model.__name__,
                            'type': field.__class__.__name__,
                            'on_delete': str(field.on_delete) if hasattr(field, 'on_delete') else None
                        })
                    elif isinstance(field, models.ManyToManyField):
                        models_data['relationships'].append({
                            'from_app': app_label,
                            'from_model': model_name,
                            'from_field': field.name,
                            'to_app': field.related_model._meta.app_label,
                            'to_model': field.related_model.__name__,
                            'type': 'ManyToManyField'
                        })

                app_models[model_name] = model_info

            models_data['apps'][app_label] = app_models

        return models_data

    def generate_dot_graph(self, models_data: dict, include_fields: bool) -> str:
        """Generate DOT format graph."""
        lines = ['digraph ModelGraph {', '  rankdir=LR;', '  node [shape=record];', '']

        # Generate nodes
        for app_label, models in models_data['apps'].items():
            lines.append(f'  subgraph cluster_{app_label} {{')
            lines.append(f'    label="{app_label}";')
            lines.append('    style=filled;')
            lines.append('    color=lightgrey;')
            lines.append('')

            for model_name, model_info in models.items():
                node_id = f'{app_label}_{model_name}'
                
                if include_fields and model_info['fields']:
                    fields_str = '|' + '\\\\l'.join(
                        f"{f['name']}: {f['type']}" for f in model_info['fields']
                    ) + '\\\\l'
                else:
                    fields_str = ''
                
                lines.append(f'    {node_id} [label="{{{model_name}{fields_str}}}"];')

            lines.append('  }')
            lines.append('')

        # Generate edges
        for rel in models_data['relationships']:
            from_node = f"{rel['from_app']}_{rel['from_model']}"
            to_node = f"{rel['to_app']}_{rel['to_model']}"
            
            edge_attrs = []
            if rel['type'] == 'ForeignKey':
                edge_attrs.append('arrowhead=normal')
            elif rel['type'] == 'OneToOneField':
                edge_attrs.append('arrowhead=none')
                edge_attrs.append('arrowtail=none')
            elif rel['type'] == 'ManyToManyField':
                edge_attrs.append('arrowhead=crow')
                edge_attrs.append('arrowtail=crow')
            
            attrs_str = f' [{", ".join(edge_attrs)}]' if edge_attrs else ''
            lines.append(f'  {from_node} -> {to_node}{attrs_str};')

        lines.append('}')
        return '\\n'.join(lines)

    def generate_mermaid_graph(self, models_data: dict, include_fields: bool) -> str:
        """Generate Mermaid format graph."""
        lines = ['erDiagram']

        # Generate entities
        for app_label, models in models_data['apps'].items():
            for model_name, model_info in models.items():
                entity_name = f'{app_label}_{model_name}'
                lines.append(f'  {entity_name} {{')
                
                if include_fields:
                    for field in model_info['fields']:
                        field_type = field['type']
                        if field.get('max_length'):
                            field_type += f"({field['max_length']})"
                        lines.append(f'    {field["name"]} {field_type}')
                
                lines.append('  }')

        # Generate relationships
        for rel in models_data['relationships']:
            from_entity = f"{rel['from_app']}_{rel['from_model']}"
            to_entity = f"{rel['to_app']}_{rel['to_model']}"
            
            if rel['type'] == 'ForeignKey':
                rel_symbol = '||--o{'
            elif rel['type'] == 'OneToOneField':
                rel_symbol = '||--||'
            elif rel['type'] == 'ManyToManyField':
                rel_symbol = '}o--o{'
            else:
                rel_symbol = '--'
            
            lines.append(f'  {from_entity} {rel_symbol} {to_entity} : {rel["from_field"]}')

        return '\\n'.join(lines)
`;

    // Database Backup Command
    files[`${projectName}/management/commands/backup_database.py`] = `"""
Management command to backup database and media files.
"""
from django.core.management.base import BaseCommand, CommandError
from django.conf import settings
from django.db import connection
import os
import subprocess
import tarfile
import gzip
from datetime import datetime
from pathlib import Path


class Command(BaseCommand):
    help = 'Backup database and optionally media files'

    def add_arguments(self, parser):
        parser.add_argument(
            '--output-dir',
            type=str,
            default='backups',
            help='Output directory for backups (default: backups)'
        )
        parser.add_argument(
            '--include-media',
            action='store_true',
            help='Include media files in backup'
        )
        parser.add_argument(
            '--compress',
            action='store_true',
            help='Compress the backup files'
        )
        parser.add_argument(
            '--prefix',
            type=str,
            default='backup',
            help='Prefix for backup filenames'
        )

    def handle(self, *args, **options):
        output_dir = Path(options['output_dir'])
        include_media = options['include_media']
        compress = options['compress']
        prefix = options['prefix']

        # Create output directory
        output_dir.mkdir(parents=True, exist_ok=True)

        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_name = f'{prefix}_{timestamp}'

        try:
            # Backup database
            db_backup_path = self.backup_database(output_dir, backup_name, compress)
            self.stdout.write(
                self.style.SUCCESS(f'Database backup created: {db_backup_path}')
            )

            # Backup media files if requested
            if include_media:
                media_backup_path = self.backup_media(output_dir, backup_name, compress)
                if media_backup_path:
                    self.stdout.write(
                        self.style.SUCCESS(f'Media backup created: {media_backup_path}')
                    )

            self.stdout.write(
                self.style.SUCCESS(f'Backup completed: {backup_name}')
            )

        except Exception as e:
            raise CommandError(f'Backup failed: {str(e)}')

    def backup_database(self, output_dir: Path, backup_name: str, compress: bool) -> Path:
        """Backup the database."""
        db_config = settings.DATABASES['default']
        engine = db_config['ENGINE']

        if 'postgresql' in engine:
            return self.backup_postgresql(output_dir, backup_name, compress, db_config)
        elif 'sqlite' in engine:
            return self.backup_sqlite(output_dir, backup_name, compress, db_config)
        else:
            raise CommandError(f'Unsupported database engine: {engine}')

    def backup_postgresql(self, output_dir: Path, backup_name: str, compress: bool, db_config: dict) -> Path:
        """Backup PostgreSQL database."""
        filename = f'{backup_name}_db.sql'
        if compress:
            filename += '.gz'
        
        backup_path = output_dir / filename

        # Build pg_dump command
        cmd = [
            'pg_dump',
            '--no-owner',
            '--no-privileges',
            '--clean',
            '--if-exists',
            f'--dbname=postgresql://{db_config["USER"]}:{db_config["PASSWORD"]}@{db_config["HOST"]}:{db_config["PORT"]}/{db_config["NAME"]}'
        ]

        try:
            with open(backup_path, 'wb') as f:
                if compress:
                    # Use gzip compression
                    process = subprocess.Popen(cmd, stdout=subprocess.PIPE)
                    with gzip.open(f, 'wb') as gz_file:
                        gz_file.write(process.stdout.read())
                    process.wait()
                else:
                    subprocess.run(cmd, stdout=f, check=True)
            
            return backup_path

        except subprocess.CalledProcessError as e:
            raise CommandError(f'pg_dump failed: {e}')
        except FileNotFoundError:
            raise CommandError('pg_dump command not found. Install PostgreSQL client tools.')

    def backup_sqlite(self, output_dir: Path, backup_name: str, compress: bool, db_config: dict) -> Path:
        """Backup SQLite database."""
        filename = f'{backup_name}_db.sqlite3'
        if compress:
            filename += '.gz'
        
        backup_path = output_dir / filename
        source_path = Path(db_config['NAME'])

        if not source_path.exists():
            raise CommandError(f'SQLite database not found: {source_path}')

        try:
            if compress:
                with open(source_path, 'rb') as src, gzip.open(backup_path, 'wb') as dst:
                    dst.write(src.read())
            else:
                import shutil
                shutil.copy2(source_path, backup_path)
            
            return backup_path

        except Exception as e:
            raise CommandError(f'SQLite backup failed: {e}')

    def backup_media(self, output_dir: Path, backup_name: str, compress: bool) -> Path:
        """Backup media files."""
        if not hasattr(settings, 'MEDIA_ROOT') or not settings.MEDIA_ROOT:
            self.stdout.write(
                self.style.WARNING('MEDIA_ROOT not configured, skipping media backup')
            )
            return None

        media_root = Path(settings.MEDIA_ROOT)
        if not media_root.exists():
            self.stdout.write(
                self.style.WARNING(f'Media directory not found: {media_root}')
            )
            return None

        filename = f'{backup_name}_media.tar'
        if compress:
            filename += '.gz'
        
        backup_path = output_dir / filename

        try:
            mode = 'w:gz' if compress else 'w'
            with tarfile.open(backup_path, mode) as tar:
                tar.add(media_root, arcname='media')
            
            return backup_path

        except Exception as e:
            raise CommandError(f'Media backup failed: {e}')
`;

    // Enhanced Settings
    files[`${projectName}/settings/__init__.py`] = '';
    
    files[`${projectName}/settings/base.py`] = `"""
Base Django settings for ${projectName} project.
"""
import os
from pathlib import Path
from decouple import config

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent.parent

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = config('SECRET_KEY', default='your-secret-key-here')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = config('DEBUG', default=False, cast=bool)

ALLOWED_HOSTS = config('ALLOWED_HOSTS', default='localhost,127.0.0.1', cast=lambda v: [s.strip() for s in v.split(',')])

# Application definition
DJANGO_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]

THIRD_PARTY_APPS = [
    'rest_framework',
    'django_filters',
    'django_extensions',
]

LOCAL_APPS = [
    '${projectName}',
]

INSTALLED_APPS = DJANGO_APPS + THIRD_PARTY_APPS + LOCAL_APPS

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = '${projectName}.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = '${projectName}.wsgi.application'

# Database
DATABASES = {
    'default': {
        'ENGINE': config('DB_ENGINE', default='django.db.backends.sqlite3'),
        'NAME': config('DB_NAME', default=BASE_DIR / 'db.sqlite3'),
        'USER': config('DB_USER', default=''),
        'PASSWORD': config('DB_PASSWORD', default=''),
        'HOST': config('DB_HOST', default=''),
        'PORT': config('DB_PORT', default=''),
        'OPTIONS': {
            'charset': 'utf8mb4',
        } if config('DB_ENGINE', default='').find('mysql') != -1 else {},
        'CONN_MAX_AGE': config('DB_CONN_MAX_AGE', default=60, cast=int),
        'CONN_HEALTH_CHECKS': True,
    }
}

# Connection pooling for PostgreSQL
if 'postgresql' in config('DB_ENGINE', default=''):
    DATABASES['default']['OPTIONS'].update({
        'MAX_CONNS': config('DB_MAX_CONNS', default=20, cast=int),
        'OPTIONS': {
            'MAX_CONNS': config('DB_MAX_CONNS', default=20, cast=int),
        }
    })

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Internationalization
LANGUAGE_CODE = config('LANGUAGE_CODE', default='en-us')
TIME_ZONE = config('TIME_ZONE', default='UTC')
USE_I18N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
STATIC_URL = '/static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'
STATICFILES_DIRS = [
    BASE_DIR / 'static',
]

# Media files
MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'

# Default primary key field type
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# REST Framework
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.TokenAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 20,
    'DEFAULT_FILTER_BACKENDS': [
        'django_filters.rest_framework.DjangoFilterBackend',
        'rest_framework.filters.SearchFilter',
        'rest_framework.filters.OrderingFilter',
    ],
    'DEFAULT_THROTTLE_CLASSES': [
        'rest_framework.throttling.AnonRateThrottle',
        'rest_framework.throttling.UserRateThrottle'
    ],
    'DEFAULT_THROTTLE_RATES': {
        'anon': '100/hour',
        'user': '1000/hour'
    }
}

# JWT Configuration (if using JWT)
from datetime import timedelta
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=60),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
    'ROTATE_REFRESH_TOKENS': True,
}

# Celery Configuration
CELERY_BROKER_URL = config('CELERY_BROKER_URL', default='redis://localhost:6379/0')
CELERY_RESULT_BACKEND = config('CELERY_RESULT_BACKEND', default='redis://localhost:6379/0')
CELERY_TASK_SERIALIZER = 'json'
CELERY_RESULT_SERIALIZER = 'json'
CELERY_ACCEPT_CONTENT = ['json']
CELERY_TIMEZONE = TIME_ZONE
CELERY_ENABLE_UTC = True

# Cache Configuration
CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': config('REDIS_URL', default='redis://127.0.0.1:6379/1'),
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        }
    }
}

# Session Configuration
SESSION_ENGINE = 'django.contrib.sessions.backends.cache'
SESSION_CACHE_ALIAS = 'default'
SESSION_COOKIE_AGE = 86400  # 24 hours
SESSION_SAVE_EVERY_REQUEST = True

# Logging Configuration
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'file': {
            'level': 'INFO',
            'class': 'logging.FileHandler',
            'filename': BASE_DIR / 'logs' / 'django.log',
            'formatter': 'verbose',
        },
        'console': {
            'level': 'INFO',
            'class': 'logging.StreamHandler',
            'formatter': 'simple',
        },
    },
    'root': {
        'handlers': ['console', 'file'],
        'level': 'INFO',
    },
    'loggers': {
        'django': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': False,
        },
        '${projectName}': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': False,
        },
    },
}

# Create logs directory
os.makedirs(BASE_DIR / 'logs', exist_ok=True)

# Database Query Settings
DATABASE_QUERY_TIMEOUT = config('DATABASE_QUERY_TIMEOUT', default=30, cast=int)
DATABASE_QUERY_LOG_THRESHOLD = config('DATABASE_QUERY_LOG_THRESHOLD', default=0.5, cast=float)

# Model Validation
MODEL_VALIDATION = {
    'ENABLE_STRICT_VALIDATION': config('ENABLE_STRICT_VALIDATION', default=True, cast=bool),
    'VALIDATE_ON_SAVE': config('VALIDATE_ON_SAVE', default=True, cast=bool),
}

# Soft Delete Support
ENABLE_SOFT_DELETE = config('ENABLE_SOFT_DELETE', default=False, cast=bool)
`;

    files[`${projectName}/settings/development.py`] = `"""
Development settings for ${projectName} project.
"""
from .base import *

# Debug settings
DEBUG = True
ALLOWED_HOSTS = ['localhost', '127.0.0.1', '0.0.0.0']

# Development apps
INSTALLED_APPS += [
    'debug_toolbar',
    'django_silk',
]

# Development middleware
MIDDLEWARE = [
    'debug_toolbar.middleware.DebugToolbarMiddleware',
    'silk.middleware.SilkyMiddleware',
] + MIDDLEWARE

# Debug toolbar configuration
INTERNAL_IPS = [
    '127.0.0.1',
    'localhost',
]

DEBUG_TOOLBAR_CONFIG = {
    'SHOW_TOOLBAR_CALLBACK': lambda request: DEBUG,
}

# Silk profiling configuration
SILKY_PYTHON_PROFILER = True
SILKY_PYTHON_PROFILER_BINARY = True
SILKY_PYTHON_PROFILER_RESULT_PATH = BASE_DIR / 'profiles'

# Database query logging
LOGGING['loggers']['django.db.backends'] = {
    'level': 'DEBUG',
    'handlers': ['console'],
    'propagate': False,
}

# Shell Plus configuration
SHELL_PLUS_IMPORTS = [
    'from django.contrib.auth.models import User',
    'from django.utils import timezone',
    'from datetime import datetime, timedelta',
]

# Graph models configuration
GRAPH_MODELS = {
    'all_applications': True,
    'group_models': True,
}

# Lower connection pool for development
if 'postgresql' in DATABASES['default']['ENGINE']:
    DATABASES['default']['OPTIONS']['MAX_CONNS'] = 5

# Development email backend
EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'

# Disable some security features for development
SECURE_SSL_REDIRECT = False
SECURE_HSTS_SECONDS = 0
SECURE_HSTS_INCLUDE_SUBDOMAINS = False
SECURE_HSTS_PRELOAD = False
`;

    files[`${projectName}/settings/production.py`] = `"""
Production settings for ${projectName} project.
"""
from .base import *

# Security settings
DEBUG = False
SECURE_SSL_REDIRECT = config('SECURE_SSL_REDIRECT', default=True, cast=bool)
SECURE_HSTS_SECONDS = config('SECURE_HSTS_SECONDS', default=31536000, cast=int)  # 1 year
SECURE_HSTS_INCLUDE_SUBDOMAINS = config('SECURE_HSTS_INCLUDE_SUBDOMAINS', default=True, cast=bool)
SECURE_HSTS_PRELOAD = config('SECURE_HSTS_PRELOAD', default=True, cast=bool)
SECURE_CONTENT_TYPE_NOSNIFF = True
SECURE_BROWSER_XSS_FILTER = True
X_FRAME_OPTIONS = 'DENY'

# Session security
SESSION_COOKIE_SECURE = True
SESSION_COOKIE_HTTPONLY = True
SESSION_COOKIE_SAMESITE = 'Strict'
CSRF_COOKIE_SECURE = True
CSRF_COOKIE_HTTPONLY = True
CSRF_COOKIE_SAMESITE = 'Strict'

# Security middleware
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',
] + MIDDLEWARE[2:]  # Skip the first SecurityMiddleware that's already included

# Higher connection pool for production
if 'postgresql' in DATABASES['default']['ENGINE']:
    DATABASES['default']['OPTIONS']['MAX_CONNS'] = 50

# Stricter query timeout for production
DATABASE_QUERY_TIMEOUT = 10

# Production logging - log to file only
LOGGING['handlers']['file']['filename'] = '/var/log/${projectName}/django.log'
LOGGING['root']['handlers'] = ['file']
LOGGING['loggers']['django']['handlers'] = ['file']
LOGGING['loggers']['${projectName}']['handlers'] = ['file']

# Email configuration
EMAIL_BACKEND = config('EMAIL_BACKEND', default='django.core.mail.backends.smtp.EmailBackend')
EMAIL_HOST = config('EMAIL_HOST', default='localhost')
EMAIL_PORT = config('EMAIL_PORT', default=587, cast=int)
EMAIL_USE_TLS = config('EMAIL_USE_TLS', default=True, cast=bool)
EMAIL_HOST_USER = config('EMAIL_HOST_USER', default='')
EMAIL_HOST_PASSWORD = config('EMAIL_HOST_PASSWORD', default='')

# Static files optimization
STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'
`;

    return files;
  },

  getPostInstallCommands(): string[] {
    return [
      'python manage.py makemigrations',
      'python manage.py migrate',
      'python manage.py collectstatic --noinput',
      'python manage.py shell -c "from django.contrib.auth.models import User; User.objects.create_superuser(\'admin\', \'admin@example.com\', \'admin\') if not User.objects.filter(username=\'admin\').exists() else None"'
    ];
  }
};